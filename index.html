<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Trading Platform - Grid Bots & Manual Trading</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .main-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .main-header h1 {
            color: #f39c12;
            font-size: 32px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .crypto-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #f39c12, #e67e22);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
        }

        .subtitle {
            color: #bdc3c7;
            font-size: 16px;
        }

        /* Main Menu Styles for Telegram */
        .main-menu {
            margin: 20px auto;
            max-width: 400px;
            padding: 0 15px;
        }
        
        .menu-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .menu-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .menu-header h2 {
            color: #f39c12;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .menu-header p {
            color: #bdc3c7;
            font-size: 14px;
            opacity: 0.8;
        }
        
        .menu-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .menu-btn {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px 15px;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100px;
            transition: all 0.3s ease;
            cursor: pointer;
            font-family: inherit;
        }
        
        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .menu-btn:active {
            transform: translateY(0);
        }
        
        .menu-emoji {
            font-size: 28px;
            margin-bottom: 8px;
            display: block;
        }
        
        .menu-title {
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            line-height: 1.2;
        }
        
        .menu-subtitle {
            font-size: 11px;
            color: #bdc3c7;
            margin-top: 4px;
            opacity: 0.8;
        }
        
        /* Colores espec√≠ficos para cada bot√≥n del men√∫ */
        .spot-grid-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important;
        }
        
        .spot-grid-btn:hover {
            box-shadow: 0 10px 25px rgba(52, 152, 219, 0.3) !important;
        }
        
        .futures-grid-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%) !important;
        }
        
        .futures-grid-btn:hover {
            box-shadow: 0 10px 25px rgba(155, 89, 182, 0.3) !important;
        }
        
        .manual-spot-btn {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%) !important;
        }
        
        .manual-spot-btn:hover {
            box-shadow: 0 10px 25px rgba(39, 174, 96, 0.3) !important;
        }
        
        .manual-futures-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
        }
        
        .manual-futures-btn:hover {
            box-shadow: 0 10px 25px rgba(231, 76, 60, 0.3) !important;
        }
        
        .menu-footer {
            text-align: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .back-to-overview {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 10px 20px;
            color: #ffffff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .back-to-overview:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .tab-navigation {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            min-width: 140px;
        }

        .tab-btn.active {
            background: linear-gradient(45deg, #3498db, #2980b9);
            border-color: #3498db;
            color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
        }

        .tab-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .main-display {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .section-title {
            color: #f39c12;
            margin-bottom: 30px;
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(243, 156, 18, 0.3);
        }

        .section-icon {
            width: 35px;
            height: 35px;
            background: linear-gradient(45deg, #f39c12, #e67e22);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }

        /* Manual Trading Specific Styles */
        .manual-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .order-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .order-type-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .order-type-btn {
            padding: 10px 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
        }

        .order-type-btn.active {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
        }

        .order-type-btn.sell.active {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .position-display {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .position-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 14px;
        }

        .pnl-positive {
            color: #2ecc71;
            font-weight: bold;
        }

        .pnl-negative {
            color: #e74c3c;
            font-weight: bold;
        }

        .liquidation-risk {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.4);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 13px;
            color: #e74c3c;
        }

        .margin-info {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 12px;
            color: #3498db;
        }

        .balance-display {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .balance-amount {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .balance-label {
            font-size: 14px;
            opacity: 0.9;
        }

        /* Shared styles from original codes */
        .form-group {
            margin-bottom: 25px;
        }

        .form-group h4 {
            color: #f39c12;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 2px solid rgba(243, 156, 18, 0.3);
            padding-bottom: 5px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #ecf0f1;
            font-weight: 500;
            font-size: 14px;
        }

        input, select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
            background: rgba(255, 255, 255, 0.15);
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-start, .btn-buy {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .btn-start:hover, .btn-buy:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(46, 204, 113, 0.3);
        }

        .btn-stop, .btn-sell {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-stop:hover, .btn-sell:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(231, 76, 60, 0.3);
        }

        .btn-start:disabled, .btn-stop:disabled, .btn-buy:disabled, .btn-sell:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stats-card {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .profit-display {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .profit-display::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .profit-amount {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .profit-percentage {
            font-size: 24px;
            opacity: 0.9;
        }

        .grid-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .info-label {
            font-size: 12px;
            color: #bdc3c7;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 18px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-active {
            background: #2ecc71;
            animation: pulse 2s infinite;
        }

        .status-inactive {
            background: #e74c3c;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .chart-container {
            margin-top: 30px;
            height: 400px;
            position: relative;
        }

        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #e74c3c;
        }

        .success {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #2ecc71;
        }

        .warning {
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            color: #f39c12;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }

        .date-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 10px 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
        }

        .mode-btn.active {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.3);
            color: #3498db;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .leverage-selector {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .leverage-btn {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
        }

        .leverage-btn.active {
            border-color: #e67e22;
            background: rgba(230, 126, 34, 0.3);
            color: #e67e22;
        }

        .leverage-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .futures-info {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 13px;
            color: #3498db;
        }

        .allocation-info {
            background: rgba(155, 89, 182, 0.1);
            border: 1px solid rgba(155, 89, 182, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 12px;
            color: #9b59b6;
        }

        .liquidation-warning {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
            color: #e74c3c;
        }

        .execution-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .execution-type {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        .execution-long, .execution-buy {
            background: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
        }

        .execution-short, .execution-sell {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
        }

        .percentage-input {
            position: relative;
        }

        .percentage-input::after {
            content: '%';
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #bdc3c7;
            font-weight: bold;
        }

        .percentage-input input {
            padding-right: 35px;
        }

        .allocation-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .allocation-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }

        .allocation-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 14px;
        }

        .allocation-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .btc-color {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .usdt-color {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .fee-info {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
            color: #e74c3c;
        }

        .edit-balance-btn {
            transition: all 0.3s ease;
        }

        .edit-balance-btn:hover {
            background: rgba(255, 255, 255, 0.3) !important;
            border-color: rgba(255, 255, 255, 0.5) !important;
            transform: translateY(-1px);
        }

        .reset-btn {
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
        }

        /* Indicators and Charts */
        .indicators-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .indicator-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 13px;
        }

        .indicator-value {
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            display: inline-block;
            min-width: 60px;
            text-align: center;
        }

        .indicator-bullish {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: #ffffff;
            border: 1px solid #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.4);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .indicator-bearish {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            color: #ffffff;
            border: 1px solid #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.4);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .indicator-neutral {
            background: linear-gradient(135deg, #5d6d7e, #85929e);
            color: #ffffff;
            border: 1px solid #85929e;
            box-shadow: 0 0 10px rgba(133, 146, 158, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Advanced Orders */
        .advanced-orders {
            background: rgba(155, 89, 182, 0.1);
            border: 1px solid rgba(155, 89, 182, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .order-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin: 10px 0;
        }

        .advanced-order-btn {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
        }

        .advanced-order-btn.active {
            border-color: #9b59b6;
            background: rgba(155, 89, 182, 0.3);
            color: #9b59b6;
        }

        /* Portfolio Dashboard */
        .portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .portfolio-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .portfolio-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .portfolio-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
        }

        .portfolio-select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }

        .portfolio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(155, 89, 182, 0.1));
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .metric-card.clickable {
            cursor: pointer;
        }

        .metric-card.clickable:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(52, 152, 219, 0.2);
            border-color: rgba(52, 152, 219, 0.4);
        }

        .metric-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .metric-icon {
            font-size: 24px;
        }

        .metric-label {
            font-size: 12px;
            color: #bdc3c7;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .metric-value {
            font-size: 28px;
            font-weight: bold;
            margin: 10px 0;
            color: #ecf0f1;
        }

        .metric-change {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .metric-trend {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 20px;
            opacity: 0.7;
        }

        /* Portfolio Main Layout */
        .portfolio-main {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
        }

        .portfolio-left {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .portfolio-right {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Chart Section */
        .chart-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-controls {
            display: flex;
            gap: 10px;
        }

        .chart-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .chart-btn.active {
            background: linear-gradient(45deg, #3498db, #2980b9);
            border-color: #3498db;
        }

        .chart-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Holdings Section */
        .holdings-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .holdings-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #e67e22, #d35400);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .holdings-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(230, 126, 34, 0.3);
        }

        .holdings-grid {
            display: grid;
            gap: 15px;
        }

        .holding-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .holding-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(5px);
        }

        .holding-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .holding-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }

        .holding-details h4 {
            margin: 0;
            font-size: 16px;
            color: #ecf0f1;
        }

        .holding-details p {
            margin: 2px 0 0 0;
            font-size: 12px;
            color: #bdc3c7;
        }

        .holding-value {
            text-align: right;
        }

        .holding-amount {
            font-size: 16px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .holding-percentage {
            font-size: 12px;
            color: #bdc3c7;
        }

        /* Performance Section */
        .performance-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .performance-grid {
            display: grid;
            gap: 12px;
        }

        .performance-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .performance-label {
            font-size: 13px;
            color: #bdc3c7;
        }

        .performance-value {
            font-size: 14px;
            font-weight: 600;
            color: #ecf0f1;
        }

        /* Risk Section */
        .risk-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .risk-indicators {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .risk-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .risk-gauge {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #f39c12, #e74c3c);
            transition: width 0.3s ease;
        }

        .risk-label {
            font-size: 12px;
            color: #bdc3c7;
        }

        .risk-value {
            font-size: 14px;
            font-weight: 600;
            color: #ecf0f1;
        }

        /* Trades Section */
        .trades-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 400px;
        }

        .trades-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .trade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            font-size: 13px;
        }

        .trade-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .trade-symbol {
            font-weight: 600;
            color: #ecf0f1;
        }

        .trade-time {
            font-size: 11px;
            color: #bdc3c7;
        }

        .trade-result {
            text-align: right;
            font-weight: 600;
        }

        .trades-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .trades-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(46, 204, 113, 0.3);
        }

        /* Advanced Orders Form */
        .advanced-form {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .advanced-form h5 {
            margin: 0 0 20px 0;
            color: #ecf0f1;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .preview-btn {
            padding: 8px 16px;
            border: 1px solid #3498db;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
        }

        .preview-btn:hover {
            background: #3498db;
            transform: translateY(-2px);
        }

        .cancel-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .cancel-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.3);
        }

        .info-box {
            background: rgba(52, 152, 219, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 12px;
            line-height: 1.4;
        }

        /* Alerts System */
        .alert-item {
            background: rgba(255, 255, 255, 0.08);
            border-left: 4px solid #f39c12;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .alert-active {
            border-left-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .alert-triggered {
            border-left-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        /* DCA Bot Styles */
        .dca-schedule {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .dca-execution {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 12px;
        }

        .dca-next {
            color: #3498db;
        }

        .dca-completed {
            color: #2ecc71;
        }

        /* Mobile Optimizations */
        .mobile-toggle {
            display: none;
        }

        @media (max-width: 1200px) {
            .container, .manual-container {
                grid-template-columns: 1fr;
            }
            
            .tab-navigation {
                flex-wrap: wrap;
                gap: 6px;
                padding: 10px;
            }
        }

        /* Responsive styles for Telegram Mobile */
        @media (max-width: 480px) {
            .main-menu {
                margin: 10px;
                padding: 0 10px;
            }
            
            .menu-container {
                padding: 20px;
            }
            
            .menu-buttons {
                gap: 12px;
            }
            
            .menu-btn {
                min-height: 80px;
                padding: 15px 10px;
            }
            
            .menu-emoji {
                font-size: 24px;
                margin-bottom: 6px;
            }
            
            .menu-title {
                font-size: 13px;
            }
            
            .menu-subtitle {
                font-size: 10px;
            }
            
            .menu-header h2 {
                font-size: 20px;
            }
            
            .container, .manual-container {
                margin: 10px;
                padding: 15px;
            }
            
            .back-to-overview {
                padding: 8px 15px;
                font-size: 12px;
            }
        }

        /* Animation styles */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .menu-container {
            animation: fadeInUp 0.6s ease-out;
        }

        .menu-btn {
            animation: fadeInUp 0.6s ease-out;
        }

        .menu-btn:nth-child(1) { animation-delay: 0.1s; }
        .menu-btn:nth-child(2) { animation-delay: 0.2s; }
        .menu-btn:nth-child(3) { animation-delay: 0.3s; }
        .menu-btn:nth-child(4) { animation-delay: 0.4s; }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .main-header h1 {
                font-size: 24px;
            }

            .tab-btn {
                min-width: 70px;
                font-size: 10px;
                padding: 6px 8px;
            }

            .control-panel, .main-display {
                padding: 20px;
            }

            .portfolio-grid {
                grid-template-columns: 1fr;
            }

            .mobile-toggle {
                display: block;
                width: 100%;
                padding: 10px;
                margin: 10px 0;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: white;
                cursor: pointer;
            }

            .mobile-hidden {
                display: none;
            }

            .mobile-visible {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <div class="main-header">
        <h1>
            <div class="crypto-icon">‚ö°</div>
            Trading Platform
        </h1>
        <div class="subtitle">Grid Trading Bots & Manual Trading | Spot & Futures <span id="connectionStatus" style="color: #2ecc71; margin-left: 15px;">üü¢ Conectado</span></div>
        <div style="margin-top: 15px;">
            <button id="resetAllData" class="reset-btn" style="padding: 8px 20px; background: linear-gradient(45deg, #e74c3c, #c0392b); border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 14px; font-weight: 600;">
                üóëÔ∏è RESETEAR TODOS LOS DATOS
            </button>
        </div>
    </div>

    <!-- MENU PRINCIPAL TELEGRAM -->
    <div class="main-menu" id="mainMenu">
        <div class="menu-container">
            <div class="menu-header">
                <h2>ü§ñ Trading Bot</h2>
                <p>Selecciona tu estrategia de trading</p>
            </div>
            
            <div class="menu-buttons">
                <button class="menu-btn spot-grid-btn" onclick="showSection('spot-grid')">
                    <span class="menu-emoji">üìä</span>
                    <span class="menu-title">Spot Grid</span>
                    <span class="menu-subtitle">Trading autom√°tico</span>
                </button>
                
                <button class="menu-btn futures-grid-btn" onclick="showSection('futures-grid')">
                    <span class="menu-emoji">‚ö°</span>
                    <span class="menu-title">Futures Grid</span>
                    <span class="menu-subtitle">Trading autom√°tico</span>
                </button>
                
                <button class="menu-btn manual-spot-btn" onclick="showSection('manual-spot')">
                    <span class="menu-emoji">üéØ</span>
                    <span class="menu-title">Manual Spot</span>
                    <span class="menu-subtitle">Control total</span>
                </button>
                
                <button class="menu-btn manual-futures-btn" onclick="showSection('manual-futures')">
                    <span class="menu-emoji">üöÄ</span>
                    <span class="menu-title">Manual Futures</span>
                    <span class="menu-subtitle">Control total</span>
                </button>
            </div>
            
            <div class="menu-footer">
                <button class="back-to-overview" onclick="showAllSections()" style="display: none;">
                    ‚Ü©Ô∏è Ver Todo
                </button>
            </div>
        </div>
    </div>

    <!-- TAB NAVIGATION (Hidden by default) -->
    <div class="tab-navigation" style="display: none;">
        <div class="tab-btn active" data-tab="spot-grid">üìä Spot Grid</div>
        <div class="tab-btn" data-tab="futures-grid">‚ö° Futures Grid</div>
        <div class="tab-btn" data-tab="manual-spot">üéØ Manual Spot</div>
        <div class="tab-btn" data-tab="manual-futures">üöÄ Manual Futures</div>
    </div>

    <!-- SPOT GRID BOT SECTION -->
    <div id="spot-grid" class="tab-content" style="display: none;">
        <div class="container">
            <div class="control-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 class="section-title" style="margin-bottom: 0;">
                        <div class="section-icon">‚Çø</div>
                        Grid Trading Bot
                    </h2>
                    <button onclick="showAllSections()" class="back-to-overview" style="display: inline-block;">
                        ‚Üê Men√∫ Principal
                    </button>
                </div>
                
                <div class="form-group">
                    <label for="symbol-spot">Selecci√≥n de Moneda</label>
                    <select id="symbol-spot">
                        <option value="BTCUSDT">BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                        <option value="TONUSDT">TON/USDT</option>
                        <option value="BNBUSDT">BNB/USDT</option>
                        <option value="ADAUSDT">ADA/USDT</option>
                        <option value="SOLUSDT">SOL/USDT</option>
                        <option value="DOGEUSDT">DOGE/USDT</option>
                    </select>
                </div>

                <div class="allocation-section">
                    <h4>‚öñÔ∏è Asignaci√≥n Inicial de Capital</h4>
                    <div class="two-column">
                        <div class="form-group">
                            <label for="cryptoAllocation-spot">% en Crypto</label>
                            <div class="percentage-input">
                                <input type="number" id="cryptoAllocation-spot" value="57.96" step="0.01" min="0" max="100">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="stablecoinAllocation-spot">% en USDT</label>
                            <div class="percentage-input">
                                <input type="number" id="stablecoinAllocation-spot" value="42.04" step="0.01" min="0" max="100">
                            </div>
                        </div>
                    </div>
                    <div id="allocationWarning-spot" class="warning" style="display: none;">
                        ‚ö†Ô∏è Los porcentajes deben sumar exactamente 100%
                    </div>
                    <div class="allocation-display">
                        <div class="allocation-item">
                            <div class="allocation-color btc-color"></div>
                            <span id="cryptoAllocationDisplay-spot">Crypto: 57.96% ($489.55)</span>
                        </div>
                        <div class="allocation-item">
                            <div class="allocation-color usdt-color"></div>
                            <span id="stablecoinAllocationDisplay-spot">USDT: 42.04% ($355.64)</span>
                        </div>
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="maxPrice-spot">Precio M√°ximo</label>
                        <input type="number" id="maxPrice-spot" value="118737" step="0.01">
                    </div>
                    <div class="form-group">
                        <label for="minPrice-spot">Precio M√≠nimo</label>
                        <input type="number" id="minPrice-spot" value="109663" step="0.01">
                    </div>
                </div>

                <div class="form-group">
                    <label for="entryPrice-spot">Precio de Entrada</label>
                    <input type="number" id="entryPrice-spot" value="113564" step="0.01">
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="gridCount-spot">Cantidad de Rejillas</label>
                        <input type="number" id="gridCount-spot" value="8" min="2" max="50">
                    </div>
                    <div class="form-group">
                        <label for="investment-spot">Inversi√≥n (USDT)</label>
                        <input type="number" id="investment-spot" value="846" step="0.01" min="10">
                    </div>
                </div>

                <div class="date-inputs">
                    <div class="form-group">
                        <label for="startDate-spot">Fecha Desde</label>
                        <input type="datetime-local" id="startDate-spot">
                    </div>
                    <div class="form-group">
                        <label for="endDate-spot">Fecha Hasta</label>
                        <input type="datetime-local" id="endDate-spot">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-start" id="startBot-spot">
                        <span class="status-indicator status-inactive"></span>
                        Iniciar Bot
                    </button>
                    <button class="btn-stop" id="stopBot-spot" disabled>
                        <span class="status-indicator status-inactive"></span>
                        Cancelar Bot
                    </button>
                </div>

                <div id="messageArea-spot"></div>
            </div>

            <div class="main-display">
                <div class="profit-display">
                    <div class="profit-amount" id="totalProfit-spot">+0.00 USDT</div>
                    <div class="profit-percentage" id="profitPercentage-spot">(+0.00%)</div>
                </div>

                <div class="grid-info">
                    <div class="info-item">
                        <div class="info-label">Precio Actual</div>
                        <div class="info-value" id="currentPrice-spot">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Rondas Completadas</div>
                        <div class="info-value" id="completedRounds-spot">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Ganancia de Rejilla</div>
                        <div class="info-value" id="gridProfit-spot">+0.00 USDT</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">PnL Trend</div>
                        <div class="info-value" id="trendPnl-spot">+0.00 USDT</div>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>Configuraci√≥n</h3>
                    <div class="fee-info">
                        <strong>‚ö†Ô∏è Fee por transacci√≥n: 0.20%</strong> (incluido en c√°lculos)
                    </div>
                    <p><strong>Rango de Trading:</strong> <span id="tradingRange-spot">--</span></p>
                    <p><strong>Tama√±o por Rejilla:</strong> <span id="gridSize-spot">--</span></p>
                    <p><strong>Inversi√≥n por Rejilla:</strong> <span id="investmentPerGrid-spot">--</span></p>
                    <p><strong>Estado:</strong> <span id="botStatus-spot">Inactivo</span></p>
                    <p><strong>Total Ejecuciones:</strong> <span id="totalExecutions-spot">0</span></p>
                </div>

                <div class="stats-card" id="executionsCard-spot" style="display: none;">
                    <h3>√öltimas Ejecuciones</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill-spot" style="width: 0%;"></div>
                    </div>
                    <div id="executionsList-spot" style="max-height: 150px; overflow-y: auto;">
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="priceChart-spot"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- FUTURES GRID BOT SECTION -->
    <div id="futures-grid" class="tab-content" style="display: none;">
        <div class="container">
            <div class="control-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 class="section-title" style="margin-bottom: 0;">
                        <div class="section-icon">‚ö°</div>
                        Futures Grid Bot
                    </h2>
                    <button onclick="showAllSections()" class="back-to-overview" style="display: inline-block;">
                        ‚Üê Men√∫ Principal
                    </button>
                </div>
                
                <div class="form-group">
                    <label for="symbol-futures">Par de Trading</label>
                    <select id="symbol-futures">
                        <option value="BTCUSDT">BTC/USDT Perpetuo</option>
                        <option value="ETHUSDT">ETH/USDT Perpetuo</option>
                        <option value="TONUSDT">TON/USDT Perpetuo</option>
                        <option value="BNBUSDT">BNB/USDT Perpetuo</option>
                        <option value="ADAUSDT">ADA/USDT Perpetuo</option>
                        <option value="SOLUSDT">SOL/USDT Perpetuo</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Modo de Futures Grid</label>
                    <div class="mode-selector">
                        <div class="mode-btn" data-mode="neutral">NEUTRAL</div>
                        <div class="mode-btn active" data-mode="long">LONG</div>
                        <div class="mode-btn" data-mode="short">SHORT</div>
                    </div>
                    <div class="futures-info" id="modeInfo-futures">
                        <strong>LONG:</strong> Adecuado para mercados alcistas vol√°tiles. Inicia con posici√≥n larga.
                    </div>
                </div>

                <div class="form-group">
                    <label for="leverage-futures">Apalancamiento</label>
                    <div class="leverage-selector">
                        <div class="leverage-btn" data-leverage="1">1x</div>
                        <div class="leverage-btn" data-leverage="2">2x</div>
                        <div class="leverage-btn" data-leverage="5">5x</div>
                        <div class="leverage-btn active" data-leverage="10">10x</div>
                        <div class="leverage-btn" data-leverage="20">20x</div>
                    </div>
                    <div class="liquidation-warning" id="leverageWarning-futures">
                        ‚ö†Ô∏è Mayor apalancamiento = Mayor riesgo de liquidaci√≥n
                    </div>
                </div>

                <div class="form-group">
                    <label for="investment-futures">Margen Total (USDT)</label>
                    <input type="number" id="investment-futures" value="846" step="0.01" min="10">
                </div>

                <div class="form-group">
                    <label>Asignaci√≥n Inicial</label>
                    <div class="two-column">
                        <div class="percentage-input">
                            <label for="cryptoPercentage-futures">En <span id="cryptoSymbol-futures">BTC</span></label>
                            <input type="number" id="cryptoPercentage-futures" value="50" min="0" max="100" step="1">
                        </div>
                        <div class="percentage-input">
                            <label for="usdtPercentage-futures">En USDT</label>
                            <input type="number" id="usdtPercentage-futures" value="50" min="0" max="100" step="1">
                        </div>
                    </div>
                    <div class="allocation-info" id="allocationInfo-futures">
                        üìä Asignaci√≥n: 50% BTC (~423 USDT) + 50% USDT (423 USDT)
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="maxPrice-futures">Precio Superior</label>
                        <input type="number" id="maxPrice-futures" value="118737" step="0.01">
                    </div>
                    <div class="form-group">
                        <label for="minPrice-futures">Precio Inferior</label>
                        <input type="number" id="minPrice-futures" value="109663" step="0.01">
                    </div>
                </div>

                <div class="form-group">
                    <label for="entryPrice-futures">Precio de Activaci√≥n</label>
                    <input type="number" id="entryPrice-futures" value="113564" step="0.01">
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="gridCount-futures">N√∫mero de Rejillas</label>
                        <input type="number" id="gridCount-futures" value="8" min="2" max="50">
                    </div>
                    <div class="form-group">
                        <label for="tradingAmount-futures">Capital por Grid (USDT)</label>
                        <input type="number" id="tradingAmount-futures" value="105.75" step="0.01" readonly>
                    </div>
                </div>

                <div class="date-inputs">
                    <div class="form-group">
                        <label for="startDate-futures">Fecha Desde</label>
                        <input type="datetime-local" id="startDate-futures">
                    </div>
                    <div class="form-group">
                        <label for="endDate-futures">Fecha Hasta</label>
                        <input type="datetime-local" id="endDate-futures">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-start" id="startBot-futures">
                        <span class="status-indicator status-inactive"></span>
                        Iniciar Bot
                    </button>
                    <button class="btn-stop" id="stopBot-futures" disabled>
                        <span class="status-indicator status-inactive"></span>
                        Cancelar Bot
                    </button>
                </div>

                <div id="messageArea-futures"></div>
            </div>

            <div class="main-display">
                <div class="profit-display">
                    <div class="profit-amount" id="totalProfit-futures">+0.00 USDT</div>
                    <div class="profit-percentage" id="profitPercentage-futures">(+0.00%)</div>
                </div>

                <div class="grid-info">
                    <div class="info-item">
                        <div class="info-label">Precio Actual</div>
                        <div class="info-value" id="currentPrice-futures">--</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Trades Completados</div>
                        <div class="info-value" id="completedTrades-futures">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Grid Profit</div>
                        <div class="info-value" id="gridProfit-futures">+0.00 USDT</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">PnL No Realizado</div>
                        <div class="info-value" id="unrealizedPnl-futures">+0.00 USDT</div>
                    </div>
                </div>

                <div class="stats-card">
                    <h3>Configuraci√≥n Futures Grid</h3>
                    <p><strong>Modo:</strong> <span id="currentMode-futures">LONG</span></p>
                    <p><strong>Apalancamiento:</strong> <span id="currentLeverage-futures">10x</span></p>
                    <p><strong>Asignaci√≥n Inicial:</strong> <span id="currentAllocation-futures">50% BTC + 50% USDT</span></p>
                    <p><strong>Rango:</strong> <span id="tradingRange-futures">--</span></p>
                    <p><strong>Intervalo por Grid:</strong> <span id="gridInterval-futures">--</span></p>
                    <p><strong>Posici√≥n por Grid:</strong> <span id="positionPerGrid-futures">--</span></p>
                    <p><strong>Precio de Liquidaci√≥n:</strong> <span id="liquidationPrice-futures">--</span></p>
                    <p><strong>Total Ejecuciones:</strong> <span id="totalExecutions-futures">0</span></p>
                    <p><strong>Funding Fees:</strong> <span id="totalFundingFees-futures">0.00 USDT</span></p>
                </div>

                <div class="stats-card" id="executionsCard-futures" style="display: none;">
                    <h3>Ejecuciones Recientes</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill-futures" style="width: 0%;"></div>
                    </div>
                    <div id="executionsList-futures" style="max-height: 150px; overflow-y: auto;">
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="priceChart-futures"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- MANUAL SPOT TRADING SECTION -->
    <div id="manual-spot" class="tab-content" style="display: none;">
        <div class="manual-container">
            <div class="order-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 class="section-title" style="margin-bottom: 0;">
                        <div class="section-icon">üéØ</div>
                        Manual Spot Trading
                    </h2>
                    <button onclick="showAllSections()" class="back-to-overview" style="display: inline-block;">
                        ‚Üê Men√∫ Principal
                    </button>
                </div>

                <div class="form-group">
                    <label for="symbol-manual-spot">Par de Trading</label>
                    <select id="symbol-manual-spot">
                        <option value="BTCUSDT">BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                        <option value="TONUSDT">TON/USDT</option>
                        <option value="BNBUSDT">BNB/USDT</option>
                        <option value="ADAUSDT">ADA/USDT</option>
                        <option value="SOLUSDT">SOL/USDT</option>
                        <option value="DOGEUSDT">DOGE/USDT</option>
                    </select>
                </div>

                <div class="balance-display">
                    <div class="balance-amount" id="spotBalance">1,000.00 USDT</div>
                    <div class="balance-label">Balance Disponible</div>
                    <button id="editBalanceSpot" class="edit-balance-btn" style="margin-top: 10px; padding: 5px 15px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer; font-size: 12px;">‚úèÔ∏è Editar Balance</button>
                </div>

                <div class="order-type-selector">
                    <div class="order-type-btn active" data-type="buy">COMPRAR</div>
                    <div class="order-type-btn sell" data-type="sell">VENDER</div>
                </div>

                <div class="form-group">
                    <label>Tipo de Orden</label>
                    <div class="two-column">
                        <div class="order-type-btn" data-order="market">MERCADO</div>
                        <div class="order-type-btn active" data-order="limit">L√çMITE</div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="orderPrice-manual-spot">Precio (USDT)</label>
                    <input type="number" id="orderPrice-manual-spot" value="95000" step="0.01">
                    <small style="color: #3498db; font-size: 11px; margin-top: 5px; display: block;">
                        üí∞ Precio Actual: $<span id="currentPriceDisplay-manual-spot">95000</span>
                    </small>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="orderQuantity-manual-spot">Cantidad</label>
                        <input type="number" id="orderQuantity-manual-spot" value="0.01" step="0.00001" min="0.00001">
                    </div>
                    <div class="form-group">
                        <label for="orderTotal-manual-spot">Total (USDT)</label>
                        <input type="number" id="orderTotal-manual-spot" value="950" step="0.01" readonly>
                    </div>
                </div>

                <div class="form-group">
                    <h4>üéØ √ìrdenes Condicionales</h4>
                    <div class="two-column">
                        <div class="form-group">
                            <label for="stopLoss-manual-spot">Stop Loss (%)</label>
                            <input type="number" id="stopLoss-manual-spot" value="5" step="0.1" min="0" placeholder="Opcional">
                        </div>
                        <div class="form-group">
                            <label for="takeProfit-manual-spot">Take Profit (%)</label>
                            <input type="number" id="takeProfit-manual-spot" value="10" step="0.1" min="0" placeholder="Opcional">
                        </div>
                    </div>
                </div>

                <div class="fee-info">
                    üí∞ <strong>Fee de Trading: 0.10%</strong> (~$0.95 por transacci√≥n)
                </div>

                <div class="button-group">
                    <button class="btn-buy" id="executeBuy-manual-spot">
                        COMPRAR <span id="buySymbol-manual-spot">BTC</span>
                    </button>
                    <button class="btn-sell" id="executeSell-manual-spot" disabled>
                        VENDER <span id="sellSymbol-manual-spot">BTC</span>
                    </button>
                </div>

                <div id="messageArea-manual-spot"></div>
            </div>

            <div class="order-panel">
                <h3 style="color: #f39c12; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                    üìà Posiciones Activas
                </h3>

                <div class="position-display" id="activePositions-manual-spot">
                    <div style="text-align: center; color: #bdc3c7; padding: 20px;">
                        No hay posiciones activas
                    </div>
                </div>

                <div class="stats-card">
                    <h3>Portfolio Spot</h3>
                    <p><strong>Balance USDT:</strong> <span id="usdtBalance-manual-spot">1,000.00 USDT</span></p>
                    <p><strong>Balance Crypto:</strong> <span id="cryptoBalance-manual-spot">0.00000 BTC</span></p>
                    <p><strong>Valor Total:</strong> <span id="totalValue-manual-spot">1,000.00 USDT</span></p>
                    <p><strong>PnL Total:</strong> <span id="totalPnl-manual-spot">+0.00 USDT (0.00%)</span></p>
                    <p><strong>Total Trades:</strong> <span id="totalTrades-manual-spot">0</span></p>
                </div>

                <div class="indicators-panel">
                    <h3 style="color: #f39c12; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        üìä Indicadores T√©cnicos
                    </h3>
                    <div id="technicalIndicators-spot">
                        <div class="indicator-item">
                            <span>RSI (14)</span>
                            <span class="indicator-value indicator-neutral" id="rsi-spot">--</span>
                        </div>
                        <div class="indicator-item">
                            <span>MACD</span>
                            <span class="indicator-value indicator-neutral" id="macd-spot">--</span>
                        </div>
                        <div class="indicator-item">
                            <span>Bollinger Bands</span>
                            <span class="indicator-value indicator-neutral" id="bb-spot">--</span>
                        </div>
                        <div class="indicator-item">
                            <span>EMA 20</span>
                            <span class="indicator-value indicator-neutral" id="ema20-spot">--</span>
                        </div>
                        <div class="indicator-item">
                            <span>Volume Trend</span>
                            <span class="indicator-value indicator-neutral" id="volume-spot">--</span>
                        </div>
                    </div>
                </div>

                <div class="advanced-orders">
                    <h4>üéØ √ìrdenes Avanzadas</h4>
                    <div class="order-type-grid">
                        <div class="advanced-order-btn" data-type="trailing-stop">Trailing Stop</div>
                        <div class="advanced-order-btn" data-type="oco">OCO</div>
                        <div class="advanced-order-btn" data-type="scale-in">Scale In</div>
                        <div class="advanced-order-btn" data-type="scale-out">Scale Out</div>
                    </div>
                    <div id="advancedOrderForm-spot" style="display: none; margin-top: 15px;">
                        <!-- Dynamic form content will be added here -->
                    </div>
                </div>

                <div class="chart-container" style="height: 300px;">
                    <canvas id="spotChart-manual"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- MANUAL FUTURES TRADING SECTION -->
    <div id="manual-futures" class="tab-content" style="display: none;">
        <div class="manual-container">
            <div class="order-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 class="section-title" style="margin-bottom: 0;">
                        <div class="section-icon">üöÄ</div>
                        Manual Futures Trading
                    </h2>
                    <button onclick="showAllSections()" class="back-to-overview" style="display: inline-block;">
                        ‚Üê Men√∫ Principal
                    </button>
                </div>

                <div class="form-group">
                    <label for="symbol-manual-futures">Par de Trading</label>
                    <select id="symbol-manual-futures">
                        <option value="BTCUSDT">BTC/USDT Perpetual</option>
                        <option value="ETHUSDT">ETH/USDT Perpetual</option>
                        <option value="TONUSDT">TON/USDT Perpetual</option>
                        <option value="BNBUSDT">BNB/USDT Perpetual</option>
                        <option value="ADAUSDT">ADA/USDT Perpetual</option>
                        <option value="SOLUSDT">SOL/USDT Perpetual</option>
                    </select>
                </div>

                <div class="balance-display">
                    <div class="balance-amount" id="futuresMargin">1,000.00 USDT</div>
                    <div class="balance-label">Margen Disponible</div>
                    <button id="editBalanceFutures" class="edit-balance-btn" style="margin-top: 10px; padding: 5px 15px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; color: white; cursor: pointer; font-size: 12px;">‚úèÔ∏è Editar Balance</button>
                </div>

                <div class="form-group">
                    <label>Apalancamiento</label>
                    <div class="leverage-selector">
                        <div class="leverage-btn" data-leverage="1">1x</div>
                        <div class="leverage-btn" data-leverage="2">2x</div>
                        <div class="leverage-btn active" data-leverage="10">10x</div>
                        <div class="leverage-btn" data-leverage="20">20x</div>
                        <div class="leverage-btn" data-leverage="50">50x</div>
                    </div>
                </div>

                <div class="order-type-selector">
                    <div class="order-type-btn active" data-type="long">LONG</div>
                    <div class="order-type-btn sell" data-type="short">SHORT</div>
                </div>

                <div class="form-group">
                    <label>Tipo de Orden</label>
                    <div class="two-column">
                        <div class="order-type-btn" data-order="market">MERCADO</div>
                        <div class="order-type-btn active" data-order="limit">L√çMITE</div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="orderPrice-manual-futures">Precio (USDT)</label>
                    <input type="number" id="orderPrice-manual-futures" value="95000" step="0.01">
                    <small style="color: #3498db; font-size: 11px; margin-top: 5px; display: block;">
                        üí∞ Precio Actual: $<span id="currentPriceDisplay-manual-futures">95000</span>
                    </small>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="orderMargin-manual-futures">Margen (USDT)</label>
                        <input type="number" id="orderMargin-manual-futures" value="100" step="0.01" min="1">
                    </div>
                    <div class="form-group">
                        <label for="orderSize-manual-futures">Tama√±o Posici√≥n</label>
                        <input type="number" id="orderSize-manual-futures" value="0.1" step="0.001" readonly>
                    </div>
                </div>

                <div class="margin-info" id="marginInfo-manual-futures">
                    üíº Margen Inicial: $100 | Posici√≥n: $1,000 | Liquidaci√≥n: ~$85,500
                </div>

                <div class="form-group">
                    <h4>üéØ Gesti√≥n de Riesgo</h4>
                    <div class="two-column">
                        <div class="form-group">
                            <label for="stopLoss-manual-futures">Stop Loss (%)</label>
                            <input type="number" id="stopLoss-manual-futures" value="3" step="0.1" min="0" placeholder="Opcional">
                        </div>
                        <div class="form-group">
                            <label for="takeProfit-manual-futures">Take Profit (%)</label>
                            <input type="number" id="takeProfit-manual-futures" value="6" step="0.1" min="0" placeholder="Opcional">
                        </div>
                    </div>
                </div>

                <div class="liquidation-risk">
                    ‚ö†Ô∏è <strong>Riesgo de Liquidaci√≥n:</strong> Precio de liquidaci√≥n calculado autom√°ticamente
                </div>

                <div class="button-group">
                    <button class="btn-buy" id="executeLong-manual-futures">
                        ABRIR LONG
                    </button>
                    <button class="btn-sell" id="executeShort-manual-futures">
                        ABRIR SHORT
                    </button>
                </div>

                <div id="messageArea-manual-futures"></div>
            </div>

            <div class="order-panel">
                <h3 style="color: #f39c12; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                    ‚ö° Posiciones Futures
                </h3>

                <div class="position-display" id="activePositions-manual-futures">
                    <div style="text-align: center; color: #bdc3c7; padding: 20px;">
                        No hay posiciones activas
                    </div>
                </div>

                <div class="stats-card">
                    <h3>Portfolio Futures</h3>
                    <p><strong>Margen Disponible:</strong> <span id="availableMargin-manual-futures">1,000.00 USDT</span></p>
                    <p><strong>Margen Usado:</strong> <span id="usedMargin-manual-futures">0.00 USDT</span></p>
                    <p><strong>PnL No Realizado:</strong> <span id="unrealizedPnl-manual-futures">+0.00 USDT</span></p>
                    <p><strong>PnL Realizado:</strong> <span id="realizedPnl-manual-futures">+0.00 USDT</span></p>
                    <p><strong>Funding Fees:</strong> <span id="fundingFees-manual-futures">0.00 USDT</span></p>
                    <p><strong>Total Trades:</strong> <span id="totalTrades-manual-futures">0</span></p>
                </div>

                <div class="chart-container" style="height: 300px;">
                    <canvas id="futuresChart-manual"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- DCA BOT SECTION (HIDDEN) -->
    <div id="dca-bot" class="tab-content" style="display: none !important; visibility: hidden;">
        <div class="container">
            <div class="control-panel">
                <h2 class="section-title">
                    <div class="section-icon">üí∞</div>
                    DCA Bot (Dollar Cost Averaging)
                </h2>
                
                <div class="form-group">
                    <label for="dca-symbol">Criptomoneda</label>
                    <select id="dca-symbol">
                        <option value="BTCUSDT">Bitcoin (BTC)</option>
                        <option value="ETHUSDT">Ethereum (ETH)</option>
                        <option value="BNBUSDT">Binance Coin (BNB)</option>
                        <option value="ADAUSDT">Cardano (ADA)</option>
                        <option value="SOLUSDT">Solana (SOL)</option>
                    </select>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="dca-amount">Cantidad por Compra (USDT)</label>
                        <input type="number" id="dca-amount" value="50" min="10" step="1">
                    </div>
                    <div class="form-group">
                        <label for="dca-frequency">Frecuencia</label>
                        <select id="dca-frequency">
                            <option value="daily">Diario</option>
                            <option value="weekly">Semanal</option>
                            <option value="monthly">Mensual</option>
                            <option value="custom">Personalizado</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label for="dca-target">Meta Total (USDT)</label>
                    <input type="number" id="dca-target" value="1000" min="100" step="50">
                </div>

                <div class="form-group">
                    <h4>üìÖ Configuraci√≥n de Tiempo</h4>
                    <div class="two-column">
                        <div>
                            <label for="dca-start-time">Hora de Ejecuci√≥n</label>
                            <input type="time" id="dca-start-time" value="10:00">
                        </div>
                        <div>
                            <label for="dca-start-date">Fecha de Inicio</label>
                            <input type="date" id="dca-start-date">
                        </div>
                    </div>
                </div>

                <div class="allocation-info">
                    üí° <strong>Estrategia DCA:</strong> Compras regulares autom√°ticas para reducir el impacto de la volatilidad
                </div>

                <div class="button-group">
                    <button class="btn-start" id="startDCA">
                        <span class="status-indicator status-inactive"></span>
                        Iniciar DCA Bot
                    </button>
                    <button class="btn-stop" id="stopDCA" disabled>
                        <span class="status-indicator status-inactive"></span>
                        Detener DCA Bot
                    </button>
                </div>

                <div id="messageArea-dca"></div>
            </div>

            <div class="main-display">
                <div class="stats-card">
                    <h3>Estado del DCA Bot</h3>
                    <p><strong>Estado:</strong> <span id="dca-status">Inactivo</span></p>
                    <p><strong>Progreso:</strong> <span id="dca-progress">$0 / $1000 (0%)</span></p>
                    <p><strong>Pr√≥xima Ejecuci√≥n:</strong> <span id="dca-next-execution">--</span></p>
                    <p><strong>Precio Promedio:</strong> <span id="dca-avg-price">--</span></p>
                    <p><strong>Total Invertido:</strong> <span id="dca-total-invested">$0</span></p>
                    <p><strong>Cantidad Acumulada:</strong> <span id="dca-total-quantity">0 BTC</span></p>
                </div>

                <div class="dca-schedule">
                    <h3>üìÖ Historial de Ejecuciones</h3>
                    <div id="dca-executions">
                        <div style="text-align: center; color: #bdc3c7; padding: 20px;">
                            No hay ejecuciones a√∫n
                        </div>
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="dcaChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- PORTFOLIO DASHBOARD SECTION (HIDDEN) -->
    <div id="portfolio" class="tab-content" style="display: none !important; visibility: hidden;">
        <!-- Header with Controls -->
        <div class="portfolio-header">
            <h2 class="section-title">
                <div class="section-icon">üìä</div>
                Portfolio Dashboard
            </h2>
            <div class="portfolio-controls">
                <button class="portfolio-btn" id="refreshPortfolio">üîÑ Actualizar</button>
                <button class="portfolio-btn" id="resetPortfolio" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">üóëÔ∏è Reiniciar</button>
                <button class="portfolio-btn" id="exportPortfolio">üìä Exportar</button>
                <select id="portfolioTimeframe" class="portfolio-select">
                    <option value="1d">1 D√≠a</option>
                    <option value="7d" selected>7 D√≠as</option>
                    <option value="30d">30 D√≠as</option>
                    <option value="90d">90 D√≠as</option>
                    <option value="1y">1 A√±o</option>
                </select>
            </div>
        </div>

        <!-- Main Metrics Grid -->
        <div class="portfolio-grid">
            <div class="metric-card clickable" data-metric="total-value">
                <div class="metric-header">
                    <div class="metric-icon">üí∞</div>
                    <div class="metric-label">Valor Total</div>
                </div>
                <div class="metric-value" id="portfolio-total-value">$0.00</div>
                <div class="metric-change" id="portfolio-total-change">$0.00 (0.00%)</div>
                <div class="metric-trend" id="portfolio-total-trend">üìà</div>
            </div>
            
            <div class="metric-card clickable" data-metric="daily-pnl">
                <div class="metric-header">
                    <div class="metric-icon">üìÖ</div>
                    <div class="metric-label">PnL Diario</div>
                </div>
                <div class="metric-value" id="portfolio-daily-pnl">$0.00</div>
                <div class="metric-change" id="portfolio-daily-change">0.00%</div>
                <div class="metric-trend" id="portfolio-daily-trend">üìä</div>
            </div>
            
            <div class="metric-card clickable" data-metric="total-trades">
                <div class="metric-header">
                    <div class="metric-icon">üîÑ</div>
                    <div class="metric-label">Trades Totales</div>
                </div>
                <div class="metric-value" id="portfolio-total-trades">0</div>
                <div class="metric-change" id="portfolio-trades-change">0 hoy</div>
                <div class="metric-trend" id="portfolio-trades-trend">üìà</div>
            </div>
            
            <div class="metric-card clickable" data-metric="win-rate">
                <div class="metric-header">
                    <div class="metric-icon">üéØ</div>
                    <div class="metric-label">Win Rate</div>
                </div>
                <div class="metric-value" id="portfolio-win-rate">0.0%</div>
                <div class="metric-change" id="portfolio-win-change">0.0%</div>
                <div class="metric-trend" id="portfolio-win-trend">‚öñÔ∏è</div>
            </div>
        </div>

        <!-- Charts and Data Section -->
        <div class="portfolio-main">
            <div class="portfolio-left">
                <!-- Portfolio Value Chart -->
                <div class="chart-section">
                    <div class="chart-header">
                        <h3>üìà Evoluci√≥n del Portfolio</h3>
                        <div class="chart-controls">
                            <button class="chart-btn active" data-chart="value">Valor</button>
                            <button class="chart-btn" data-chart="pnl">PnL</button>
                            <button class="chart-btn" data-chart="allocation">Distribuci√≥n</button>
                        </div>
                    </div>
                    <div class="chart-container" style="height: 400px;">
                        <canvas id="portfolioChart"></canvas>
                    </div>
                </div>

                <!-- Holdings Distribution -->
                <div class="holdings-section">
                    <div class="section-header">
                        <h3>üíº Holdings Actuales</h3>
                        <button class="holdings-btn" id="rebalancePortfolio">‚öñÔ∏è Rebalancear</button>
                    </div>
                    <div id="portfolio-holdings" class="holdings-grid">
                        <!-- Holdings will be populated dynamically -->
                    </div>
                </div>
            </div>

            <div class="portfolio-right">
                <!-- Performance Metrics -->
                <div class="performance-section">
                    <h3>üìä M√©tricas de Performance</h3>
                    <div class="performance-grid">
                        <div class="performance-item">
                            <span class="performance-label">ROI Total</span>
                            <span class="performance-value" id="portfolio-roi-total">0.00%</span>
                        </div>
                        <div class="performance-item">
                            <span class="performance-label">ROI Anualizado</span>
                            <span class="performance-value" id="portfolio-roi-annual">0.00%</span>
                        </div>
                        <div class="performance-item">
                            <span class="performance-label">Sharpe Ratio</span>
                            <span class="performance-value" id="portfolio-sharpe">0.00</span>
                        </div>
                        <div class="performance-item">
                            <span class="performance-label">Max Drawdown</span>
                            <span class="performance-value" id="portfolio-drawdown">0.00%</span>
                        </div>
                        <div class="performance-item">
                            <span class="performance-label">Volatilidad</span>
                            <span class="performance-value" id="portfolio-volatility">0.00%</span>
                        </div>
                        <div class="performance-item">
                            <span class="performance-label">Mejor Trade</span>
                            <span class="performance-value" id="portfolio-best-trade">$0.00</span>
                        </div>
                        <div class="performance-item">
                            <span class="performance-label">Peor Trade</span>
                            <span class="performance-value" id="portfolio-worst-trade">$0.00</span>
                        </div>
                        <div class="performance-item">
                            <span class="performance-label">Avg Trade</span>
                            <span class="performance-value" id="portfolio-avg-trade">$0.00</span>
                        </div>
                    </div>
                </div>

                <!-- Risk Management -->
                <div class="risk-section">
                    <h3>üõ°Ô∏è Gesti√≥n de Riesgo</h3>
                    <div class="risk-indicators">
                        <div class="risk-item">
                            <div class="risk-gauge" id="risk-level-gauge">
                                <div class="gauge-fill" style="width: 60%;"></div>
                            </div>
                            <span class="risk-label">Nivel de Riesgo</span>
                            <span class="risk-value" id="risk-level-value">Moderado</span>
                        </div>
                        <div class="risk-item">
                            <div class="risk-gauge" id="diversification-gauge">
                                <div class="gauge-fill" style="width: 75%;"></div>
                            </div>
                            <span class="risk-label">Diversificaci√≥n</span>
                            <span class="risk-value" id="diversification-value">75/100</span>
                        </div>
                        <div class="risk-item">
                            <div class="risk-gauge" id="exposure-gauge">
                                <div class="gauge-fill" style="width: 40%;"></div>
                            </div>
                            <span class="risk-label">Exposici√≥n</span>
                            <span class="risk-value" id="exposure-value">40%</span>
                        </div>
                    </div>
                </div>

                <!-- Recent Trades -->
                <div class="trades-section">
                    <h3>üìà Trades Recientes</h3>
                    <div id="recent-trades" class="trades-list">
                        <!-- Recent trades will be populated dynamically -->
                    </div>
                    <button class="trades-btn" id="viewAllTrades">Ver Todos los Trades</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ANALYTICS SECTION (HIDDEN) -->
    <div id="analytics" class="tab-content" style="display: none !important; visibility: hidden;">
        <div class="container">
            <div class="control-panel">
                <h2 class="section-title">
                    <div class="section-icon">üìä</div>
                    Analytics & Backtesting
                </h2>
                
                <div class="form-group">
                    <h4>üîÑ Backtest Strategy</h4>
                    <div class="mode-selector">
                        <div class="mode-btn active" data-strategy="sma-cross">SMA Cross</div>
                        <div class="mode-btn" data-strategy="rsi">RSI Strategy</div>
                        <div class="mode-btn" data-strategy="macd">MACD Strategy</div>
                    </div>
                </div>

                <div class="two-column">
                    <div class="form-group">
                        <label for="backtest-start">Fecha Inicio</label>
                        <input type="date" id="backtest-start" value="2024-01-01">
                    </div>
                    <div class="form-group">
                        <label for="backtest-end">Fecha Fin</label>
                        <input type="date" id="backtest-end">
                    </div>
                </div>

                <div class="form-group">
                    <label for="backtest-capital">Capital Inicial</label>
                    <input type="number" id="backtest-capital" value="10000" min="1000" step="100">
                </div>

                <div class="button-group">
                    <button class="btn-start" id="runBacktest">
                        üîÑ Ejecutar Backtest
                    </button>
                    <button class="btn-stop" id="exportResults">
                        üìä Exportar Resultados
                    </button>
                </div>

                <div id="messageArea-analytics"></div>
            </div>

            <div class="main-display">
                <div class="stats-card">
                    <h3>üìà Resultados del Backtest</h3>
                    <div class="grid-info">
                        <div class="info-item">
                            <div class="info-label">ROI Total</div>
                            <div class="info-value" id="backtest-roi">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Sharpe Ratio</div>
                            <div class="info-value" id="backtest-sharpe">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Max Drawdown</div>
                            <div class="info-value" id="backtest-drawdown">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Win Rate</div>
                            <div class="info-value" id="backtest-winrate">--</div>
                        </div>
                    </div>
                </div>

                <div class="indicators-panel">
                    <h3>üéØ Strategy Parameters</h3>
                    <div id="strategy-params">
                        <div class="indicator-item">
                            <span>Total Trades</span>
                            <span id="backtest-trades">--</span>
                        </div>
                        <div class="indicator-item">
                            <span>Avg Trade Duration</span>
                            <span id="backtest-duration">--</span>
                        </div>
                        <div class="indicator-item">
                            <span>Profit Factor</span>
                            <span id="backtest-profit-factor">--</span>
                        </div>
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="backtestChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- ALERTS SYSTEM SECTION (HIDDEN) -->
    <div id="alerts" class="tab-content" style="display: none !important; visibility: hidden;">
        <div class="container">
            <div class="control-panel">
                <h2 class="section-title">
                    <div class="section-icon">üîî</div>
                    Sistema de Alertas
                </h2>
                
                <div class="form-group">
                    <label for="alert-symbol">S√≠mbolo</label>
                    <select id="alert-symbol">
                        <option value="BTCUSDT">BTC/USDT</option>
                        <option value="ETHUSDT">ETH/USDT</option>
                        <option value="BNBUSDT">BNB/USDT</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Tipo de Alerta</label>
                    <div class="mode-selector">
                        <div class="mode-btn active" data-alert="price">Precio</div>
                        <div class="mode-btn" data-alert="indicator">Indicador</div>
                        <div class="mode-btn" data-alert="volume">Volumen</div>
                    </div>
                </div>

                <div class="form-group" id="price-alert-form">
                    <div class="two-column">
                        <div>
                            <label for="alert-condition">Condici√≥n</label>
                            <select id="alert-condition">
                                <option value="above">Precio > </option>
                                <option value="below">Precio < </option>
                                <option value="cross-up">Cruza hacia arriba</option>
                                <option value="cross-down">Cruza hacia abajo</option>
                            </select>
                        </div>
                        <div>
                            <label for="alert-value">Valor</label>
                            <input type="number" id="alert-value" placeholder="Ej: 95000" step="0.01">
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="alert-message">Mensaje Personalizado</label>
                    <input type="text" id="alert-message" placeholder="BTC alcanz√≥ el precio objetivo">
                </div>

                <div class="form-group">
                    <h4>üîä Notificaciones</h4>
                    <div class="two-column">
                        <label><input type="checkbox" id="alert-browser" checked> Navegador</label>
                        <label><input type="checkbox" id="alert-sound" checked> Sonido</label>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-start" id="createAlert">
                        ‚ûï Crear Alerta
                    </button>
                    <button class="btn-stop" id="testAlert">
                        üîä Probar Sonido
                    </button>
                </div>

                <div id="messageArea-alerts"></div>
            </div>

            <div class="main-display">
                <h3 style="color: #f39c12; margin-bottom: 20px;">üîî Alertas Activas</h3>
                
                <div id="activeAlerts">
                    <div class="alert-item alert-active">
                        <div>
                            <strong>BTC/USDT</strong><br>
                            Precio > $96,000
                        </div>
                        <div>
                            <span style="color: #2ecc71;">Activa</span>
                            <button onclick="removeAlert(1)" style="margin-left: 10px; padding: 2px 6px; background: #e74c3c; border: none; border-radius: 3px; color: white; cursor: pointer;">√ó</button>
                        </div>
                    </div>
                    
                    <div class="alert-item">
                        <div>
                            <strong>ETH/USDT</strong><br>
                            RSI < 30
                        </div>
                        <div>
                            <span style="color: #f39c12;">Pendiente</span>
                            <button onclick="removeAlert(2)" style="margin-left: 10px; padding: 2px 6px; background: #e74c3c; border: none; border-radius: 3px; color: white; cursor: pointer;">√ó</button>
                        </div>
                    </div>
                </div>

                <div class="stats-card" style="margin-top: 20px;">
                    <h3>üìä Estad√≠sticas de Alertas</h3>
                    <p><strong>Alertas Activas:</strong> <span id="alerts-active-count">2</span></p>
                    <p><strong>Alertas Disparadas Hoy:</strong> <span id="alerts-triggered-today">5</span></p>
                    <p><strong>Alertas Totales:</strong> <span id="alerts-total-count">24</span></p>
                </div>

                <div class="chart-container">
                    <canvas id="alertsChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data Persistence Manager
        class DataManager {
            static saveData(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                } catch (error) {
                    console.error('Error saving data:', error);
                }
            }

            static loadData(key, defaultValue = null) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : defaultValue;
                } catch (error) {
                    console.error('Error loading data:', error);
                    return defaultValue;
                }
            }

            static clearAllData() {
                try {
                    // Lista completa de todas las claves de datos
                    const keys = [
                        'manualSpotData',
                        'manualFuturesData',
                        'spotGridData',
                        'futuresGridData',
                        'dcaBotData',
                        'alertsData',
                        'portfolioData',
                        'analyticsData'
                    ];
                    
                    keys.forEach(key => {
                        localStorage.removeItem(key);
                    });
                    
                    console.log('All trading data cleared from localStorage');
                    return true;
                } catch (error) {
                    console.error('Error clearing data:', error);
                    return false;
                }
            }

            static resetAllInstances() {
                try {
                    // Detener todos los intervalos y limpiar estados
                    if (window.manualSpotTrader) {
                        window.manualSpotTrader.usdtBalance = 1000.00;
                        window.manualSpotTrader.cryptoBalance = 0;
                        window.manualSpotTrader.totalValue = 1000.00;
                        window.manualSpotTrader.totalPnl = 0;
                        window.manualSpotTrader.totalTrades = 0;
                        window.manualSpotTrader.activePositions = [];
                        window.manualSpotTrader.tradeHistory = [];
                        window.manualSpotTrader.updateDisplay();
                    }
                    
                    if (window.manualFuturesTrader) {
                        window.manualFuturesTrader.availableMargin = 1000.00;
                        window.manualFuturesTrader.usedMargin = 0;
                        window.manualFuturesTrader.unrealizedPnl = 0;
                        window.manualFuturesTrader.realizedPnl = 0;
                        window.manualFuturesTrader.fundingFees = 0;
                        window.manualFuturesTrader.totalTrades = 0;
                        window.manualFuturesTrader.activePositions = [];
                        window.manualFuturesTrader.tradeHistory = [];
                        window.manualFuturesTrader.updateDisplay();
                    }
                    
                    if (window.dcaBot) {
                        if (window.dcaBot.dcaInterval) {
                            clearInterval(window.dcaBot.dcaInterval);
                        }
                        window.dcaBot.isRunning = false;
                        window.dcaBot.totalInvested = 0;
                        window.dcaBot.totalQuantity = 0;
                        window.dcaBot.averagePrice = 0;
                        window.dcaBot.executions = [];
                        window.dcaBot.nextExecution = null;
                        window.dcaBot.updateDisplay();
                    }
                    
                    if (window.alertsSystem) {
                        window.alertsSystem.alerts = [];
                        window.alertsSystem.activeCount = 0;
                        window.alertsSystem.triggeredToday = 0;
                        window.alertsSystem.totalCount = 0;
                        window.alertsSystem.updateDisplay();
                    }
                    
                    if (window.spotGridBot) {
                        window.spotGridBot.stopBot();
                    }
                    
                    if (window.futuresGridBot) {
                        window.futuresGridBot.stopBot();
                    }
                    
                    console.log('All instances reset successfully');
                } catch (error) {
                    console.error('Error resetting instances:', error);
                }
            }

            static setupResetButton() {
                const resetButton = document.getElementById('resetAllData');
                if (!resetButton) {
                    console.error('Reset button not found');
                    return;
                }
                
                resetButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    const confirmation = confirm(
                        '‚ö†Ô∏è ¬øEst√°s seguro de que quieres RESETEAR TODOS LOS DATOS?\n\n' +
                        'Esto borrar√°:\n' +
                        '‚Ä¢ Todos los balances\n' +
                        '‚Ä¢ Todas las posiciones activas\n' +
                        '‚Ä¢ Todo el historial de trades\n' +
                        '‚Ä¢ Configuraciones guardadas\n' +
                        '‚Ä¢ Datos del DCA Bot\n' +
                        '‚Ä¢ Alertas creadas\n\n' +
                        'Esta acci√≥n NO se puede deshacer.'
                    );
                    
                    if (confirmation) {
                        try {
                            // Mostrar mensaje de procesamiento
                            resetButton.disabled = true;
                            resetButton.textContent = 'üîÑ Borrando datos...';
                            
                            // Limpiar datos
                            const success = DataManager.clearAllData();
                            
                            if (success) {
                                resetButton.textContent = '‚úÖ Datos borrados';
                                
                                // Resetear todas las instancias sin recargar la p√°gina
                                DataManager.resetAllInstances();
                                
                                // Mostrar mensaje de √©xito
                                setTimeout(() => {
                                    resetButton.disabled = false;
                                    resetButton.textContent = 'üóëÔ∏è RESETEAR TODOS LOS DATOS';
                                    alert('‚úÖ Todos los datos han sido borrados exitosamente');
                                }, 1000);
                            } else {
                                throw new Error('Failed to clear data');
                            }
                        } catch (error) {
                            console.error('Error during reset:', error);
                            resetButton.disabled = false;
                            resetButton.textContent = 'üóëÔ∏è RESETEAR TODOS LOS DATOS';
                            alert('‚ùå Error al borrar los datos. Por favor recarga la p√°gina manualmente.');
                        }
                    }
                });
            }
        }

        // Tab Management
        class TabManager {
            constructor() {
                this.activeTab = 'spot-grid';
                this.init();
            }

            init() {
                this.setupTabEventListeners();
            }

            setupTabEventListeners() {
                const tabButtons = document.querySelectorAll('.tab-btn');
                console.log('Setting up tab listeners for', tabButtons.length, 'buttons');
                
                tabButtons.forEach(btn => {
                    if (btn.dataset.tab) {
                        btn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('Tab clicked:', btn.dataset.tab);
                            this.switchTab(btn.dataset.tab);
                        });
                        console.log('Listener added for tab:', btn.dataset.tab);
                    } else {
                        console.warn('Tab button missing data-tab attribute:', btn);
                    }
                });
            }

            switchTab(tabId) {
                if (!tabId) {
                    console.error('No tabId provided to switchTab');
                    return;
                }
                
                console.log('Switching to tab:', tabId);
                
                try {
                    // Hide all tab contents
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });

                    // Remove active class from all tab buttons
                    document.querySelectorAll('.tab-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });

                    // Show selected tab content
                    const targetTab = document.getElementById(tabId);
                    if (targetTab) {
                        targetTab.classList.add('active');
                        console.log('Tab content shown:', tabId);
                    } else {
                        console.error('Tab content not found:', tabId);
                        return;
                    }

                    // Add active class to selected tab button
                    const targetButton = document.querySelector(`[data-tab="${tabId}"]`);
                    if (targetButton) {
                        targetButton.classList.add('active');
                        console.log('Tab button activated:', tabId);
                    } else {
                        console.error('Tab button not found:', tabId);
                    }

                    this.activeTab = tabId;

                    // Initialize respective modules when tab is activated
                    this.initializeTabModule(tabId);
                    
                    console.log('Tab switch completed successfully');
                } catch (error) {
                    console.error('Error switching tabs:', error);
                }
            }

            initializeTabModule(tabId) {
                switch(tabId) {
                    case 'spot-grid':
                        if (!window.spotGridBot) {
                            window.spotGridBot = new SpotGridTradingBot();
                        }
                        break;
                    case 'futures-grid':
                        if (!window.futuresGridBot) {
                            window.futuresGridBot = new FuturesGridTradingBot();
                        }
                        break;
                    case 'manual-spot':
                        if (!window.manualSpotTrader) {
                            window.manualSpotTrader = new ManualSpotTrader();
                        }
                        break;
                    case 'manual-futures':
                        if (!window.manualFuturesTrader) {
                            window.manualFuturesTrader = new ManualFuturesTrader();
                        }
                        break;
                    case 'dca-bot':
                        if (!window.dcaBot) {
                            window.dcaBot = new DCABot();
                        }
                        break;
                    case 'portfolio':
                        if (!window.portfolioManager) {
                            window.portfolioManager = new PortfolioManager();
                        }
                        break;
                    case 'analytics':
                        if (!window.analytics) {
                            window.analytics = new Analytics();
                        }
                        break;
                    case 'alerts':
                        if (!window.alertsSystem) {
                            window.alertsSystem = new AlertsSystem();
                        }
                        break;
                }
            }
        }

        // Spot Grid Trading Bot (Modified from original)
        class SpotGridTradingBot {
            constructor() {
                this.isRunning = false;
                this.currentPrice = 0;
                this.priceHistory = [];
                this.profits = [];
                this.totalProfit = 0;
                this.gridProfit = 0;
                this.trendPnl = 0;
                this.completedRounds = 0;
                this.gridLevels = [];
                this.priceChart = null;
                this.updateInterval = null;
                this.simulationSpeed = 1000;
                this.historicalData = null;
                this.historicalIndex = 0;
                this.lastPrice = 0;
                this.gridExecutions = [];
                this.btcAllocation = 0;
                this.usdtAllocation = 0;
                this.btcQuantityPerGrid = 0;
                this.gridInterval = 0;
                this.suffix = '-spot';
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.initializeChart();
                this.setDefaultDates();
                this.updateGridCalculations();
                this.getCurrentPrice();
                this.updateAllocationDisplay();
            }

            setupEventListeners() {
                document.getElementById(`startBot${this.suffix}`).addEventListener('click', () => this.startBot());
                document.getElementById(`stopBot${this.suffix}`).addEventListener('click', () => this.stopBot());
                
                ['maxPrice', 'minPrice', 'gridCount', 'investment'].forEach(id => {
                    const element = document.getElementById(`${id}${this.suffix}`);
                    if (element) {
                        element.addEventListener('input', () => this.updateGridCalculations());
                    }
                });

                ['cryptoAllocation', 'stablecoinAllocation', 'investment'].forEach(id => {
                    const element = document.getElementById(`${id}${this.suffix}`);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.validateAllocation();
                            this.updateAllocationDisplay();
                            this.updateGridCalculations();
                        });
                    }
                });

                const symbolElement = document.getElementById(`symbol${this.suffix}`);
                if (symbolElement) {
                    symbolElement.addEventListener('change', () => {
                        this.getCurrentPrice();
                        this.updateGridCalculations();
                        this.updateAllocationDisplay();
                    });
                }
            }

            validateAllocation() {
                const cryptoPercent = parseFloat(document.getElementById(`cryptoAllocation${this.suffix}`).value) || 0;
                const stablecoinPercent = parseFloat(document.getElementById(`stablecoinAllocation${this.suffix}`).value) || 0;
                const total = cryptoPercent + stablecoinPercent;
                
                const warningElement = document.getElementById(`allocationWarning${this.suffix}`);
                
                if (Math.abs(total - 100) > 0.01) {
                    if (warningElement) {
                        warningElement.style.display = 'block';
                        warningElement.textContent = `‚ö†Ô∏è Total: ${total.toFixed(2)}% - Los porcentajes deben sumar 100%`;
                    }
                    return false;
                } else {
                    if (warningElement) {
                        warningElement.style.display = 'none';
                    }
                    return true;
                }
            }

            updateAllocationDisplay() {
                const totalInvestment = parseFloat(document.getElementById(`investment${this.suffix}`).value) || 0;
                const cryptoPercent = parseFloat(document.getElementById(`cryptoAllocation${this.suffix}`).value) || 0;
                const stablecoinPercent = parseFloat(document.getElementById(`stablecoinAllocation${this.suffix}`).value) || 0;
                
                const cryptoAmount = totalInvestment * (cryptoPercent / 100);
                const stablecoinAmount = totalInvestment * (stablecoinPercent / 100);
                
                const symbolElement = document.getElementById(`symbol${this.suffix}`);
                const symbol = symbolElement ? symbolElement.value.replace('USDT', '') : 'BTC';
                
                const cryptoDisplay = document.getElementById(`cryptoAllocationDisplay${this.suffix}`);
                const stablecoinDisplay = document.getElementById(`stablecoinAllocationDisplay${this.suffix}`);
                
                if (cryptoDisplay) {
                    cryptoDisplay.textContent = `${symbol}: ${cryptoPercent}% ($${cryptoAmount.toFixed(2)})`;
                }
                if (stablecoinDisplay) {
                    stablecoinDisplay.textContent = `USDT: ${stablecoinPercent}% ($${stablecoinAmount.toFixed(2)})`;
                }
            }

            setDefaultDates() {
                const startDate = new Date('2025-08-20T10:00:00');
                const endDate = new Date();
                
                const startElement = document.getElementById(`startDate${this.suffix}`);
                const endElement = document.getElementById(`endDate${this.suffix}`);
                
                if (startElement) startElement.value = startDate.toISOString().slice(0, 16);
                if (endElement) endElement.value = endDate.toISOString().slice(0, 16);
            }

            updateGridCalculations() {
                const maxPrice = parseFloat(document.getElementById(`maxPrice${this.suffix}`).value);
                const minPrice = parseFloat(document.getElementById(`minPrice${this.suffix}`).value);
                const gridCount = parseInt(document.getElementById(`gridCount${this.suffix}`).value);
                const totalInvestment = parseFloat(document.getElementById(`investment${this.suffix}`).value);

                if (maxPrice <= minPrice) {
                    this.showMessage('El precio m√°ximo debe ser mayor al m√≠nimo', 'error');
                    return;
                }

                const cryptoAllocationPercent = parseFloat(document.getElementById(`cryptoAllocation${this.suffix}`).value) || 57.96;
                const stablecoinAllocationPercent = parseFloat(document.getElementById(`stablecoinAllocation${this.suffix}`).value) || 42.04;
                
                if (!this.validateAllocation()) {
                    return;
                }
                
                const cryptoAllocation = totalInvestment * (cryptoAllocationPercent / 100);
                const stablecoinAllocation = totalInvestment * (stablecoinAllocationPercent / 100);
                
                const priceRange = maxPrice - minPrice;
                const gridInterval = priceRange / (gridCount - 1);
                
                const entryPrice = parseFloat(document.getElementById(`entryPrice${this.suffix}`).value) || ((maxPrice + minPrice) / 2);
                const cryptoQuantityPerGrid = cryptoAllocation / (gridCount * entryPrice);
                
                const rangeElement = document.getElementById(`tradingRange${this.suffix}`);
                const sizeElement = document.getElementById(`gridSize${this.suffix}`);
                const investmentElement = document.getElementById(`investmentPerGrid${this.suffix}`);
                
                if (rangeElement) {
                    rangeElement.textContent = `${minPrice.toLocaleString()} - ${maxPrice.toLocaleString()}`;
                }
                if (sizeElement) {
                    sizeElement.textContent = `${gridInterval.toFixed(2)} USDT por nivel`;
                }
                if (investmentElement) {
                    const symbol = document.getElementById(`symbol${this.suffix}`).value.replace('USDT', '');
                    investmentElement.textContent = `${cryptoQuantityPerGrid.toFixed(6)} ${symbol} por rejilla`;
                }
                
                this.gridLevels = [];
                for (let i = 0; i < gridCount; i++) {
                    const price = minPrice + (i * gridInterval);
                    this.gridLevels.push({
                        price: price,
                        cryptoQuantity: cryptoQuantityPerGrid,
                        gridInterval: gridInterval
                    });
                }

                this.cryptoAllocation = cryptoAllocation;
                this.usdtAllocation = stablecoinAllocation;
                this.cryptoQuantityPerGrid = cryptoQuantityPerGrid;
                this.gridInterval = gridInterval;
            }

            async getCurrentPrice() {
                try {
                    const symbolElement = document.getElementById(`symbol${this.suffix}`);
                    const symbol = symbolElement ? symbolElement.value : 'BTCUSDT';
                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
                    const data = await response.json();
                    
                    // Update connection status
                    this.updateConnectionStatus(true);
                    
                    this.currentPrice = parseFloat(data.price);
                    const currentPriceElement = document.getElementById(`currentPrice${this.suffix}`);
                    if (currentPriceElement) {
                        currentPriceElement.textContent = 
                            `${this.currentPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} USDT`;
                    }
                    
                    if (!this.isRunning) {
                        const entryPriceElement = document.getElementById(`entryPrice${this.suffix}`);
                        if (entryPriceElement) {
                            entryPriceElement.value = this.currentPrice;
                        }
                    }
                } catch (error) {
                    this.updateConnectionStatus(false);
                    this.showMessage('Error al obtener precio actual: ' + error.message, 'error');
                }
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    if (connected) {
                        statusElement.innerHTML = 'üü¢ Conectado';
                        statusElement.style.color = '#2ecc71';
                    } else {
                        statusElement.innerHTML = 'üî¥ Error de Conexi√≥n';
                        statusElement.style.color = '#e74c3c';
                    }
                }
            }

            initializeChart() {
                const ctx = document.getElementById(`priceChart${this.suffix}`);
                if (!ctx) return;
                
                this.priceChart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Precio',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4
                        }, {
                            label: 'Ganancias',
                            data: [],
                            borderColor: '#2ecc71',
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ecf0f1'
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                ticks: { color: '#2ecc71' },
                                grid: { drawOnChartArea: false }
                            }
                        }
                    }
                });
            }

            async startBot() {
                if (this.isRunning) return;

                try {
                    this.validateInputs();
                    this.showMessage('Cargando datos hist√≥ricos...', 'success');
                    
                    await this.loadHistoricalData();
                    
                    this.isRunning = true;
                    this.updateButtonStates();
                    this.resetSimulation();
                    this.startHistoricalSimulation();
                    
                    this.showMessage(`Bot iniciado - Simulando ${this.historicalData.length} per√≠odos hist√≥ricos`, 'success');
                } catch (error) {
                    this.showMessage('Error al iniciar bot: ' + error.message, 'error');
                    this.isRunning = false;
                    this.updateButtonStates();
                }
            }

            async loadHistoricalData() {
                const symbolElement = document.getElementById(`symbol${this.suffix}`);
                const startDateElement = document.getElementById(`startDate${this.suffix}`);
                const endDateElement = document.getElementById(`endDate${this.suffix}`);
                
                const symbol = symbolElement ? symbolElement.value : 'BTCUSDT';
                const startDate = startDateElement ? startDateElement.value : '';
                const endDate = endDateElement ? endDateElement.value : '';
                
                if (!startDate || !endDate) {
                    throw new Error('Por favor selecciona fechas v√°lidas');
                }

                const startTime = new Date(startDate).getTime();
                const endTime = new Date(endDate).getTime();
                
                if (startTime >= endTime) {
                    throw new Error('La fecha de inicio debe ser anterior a la fecha final');
                }

                try {
                    const response = await fetch(
                        `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=5m&startTime=${startTime}&endTime=${endTime}&limit=1000`
                    );
                    
                    if (!response.ok) {
                        throw new Error(`Error de API: ${response.status}`);
                    }
                    
                    this.historicalData = await response.json();
                    this.historicalIndex = 0;
                    
                    if (this.historicalData.length === 0) {
                        throw new Error('No se encontraron datos para el per√≠odo seleccionado');
                    }
                    
                    console.log(`Cargados ${this.historicalData.length} puntos de datos hist√≥ricos`);
                } catch (error) {
                    throw new Error(`Error al cargar datos hist√≥ricos: ${error.message}`);
                }
            }

            startHistoricalSimulation() {
                this.simulationSpeed = 200;
                this.updateInterval = setInterval(() => {
                    if (!this.isRunning) return;

                    try {
                        this.simulateGridTrading();
                        
                        if (this.historicalIndex % 5 === 0) {
                            this.updateChart();
                            this.updateDisplay();
                        }
                    } catch (error) {
                        console.error('Simulation error:', error);
                        this.showMessage('Error en simulaci√≥n: ' + error.message, 'error');
                    }
                }, this.simulationSpeed);
            }

            stopBot() {
                this.isRunning = false;
                this.updateButtonStates();
                
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
                
                const totalExecutions = this.gridExecutions.length;
                const finalProfit = this.totalProfit;
                
                this.showMessage(
                    `Bot detenido - ${totalExecutions} ejecuciones, Ganancia: ${finalProfit >= 0 ? '+' : ''}${finalProfit.toFixed(2)} USDT`, 
                    'error'
                );
            }

            validateInputs() {
                const maxPrice = parseFloat(document.getElementById(`maxPrice${this.suffix}`).value);
                const minPrice = parseFloat(document.getElementById(`minPrice${this.suffix}`).value);
                const investment = parseFloat(document.getElementById(`investment${this.suffix}`).value);
                const gridCount = parseInt(document.getElementById(`gridCount${this.suffix}`).value);

                if (maxPrice <= minPrice) throw new Error('Precio m√°ximo debe ser mayor al m√≠nimo');
                if (investment < 10) throw new Error('Inversi√≥n m√≠nima: 10 USDT');
                if (gridCount < 2) throw new Error('M√≠nimo 2 rejillas');
                if (gridCount > 50) throw new Error('M√°ximo 50 rejillas');
                if (!this.validateAllocation()) throw new Error('Los porcentajes de asignaci√≥n deben sumar 100%');
            }

            resetSimulation() {
                this.totalProfit = 0;
                this.gridProfit = 0;
                this.trendPnl = 0;
                this.completedRounds = 0;
                this.priceHistory = [];
                this.profits = [];
                this.gridExecutions = [];
                this.lastPrice = 0;
                this.historicalIndex = 0;
                this.updateDisplay();
                
                if (this.priceChart) {
                    this.priceChart.data.labels = [];
                    this.priceChart.data.datasets[0].data = [];
                    this.priceChart.data.datasets[1].data = [];
                    this.priceChart.update();
                }
            }

            async simulateGridTrading() {
                if (this.historicalData && this.historicalIndex < this.historicalData.length) {
                    const currentData = this.historicalData[this.historicalIndex];
                    const simulatedPrice = parseFloat(currentData[4]);
                    
                    this.priceHistory.push({
                        time: new Date(currentData[6]),
                        price: simulatedPrice
                    });

                    this.processGridOrders(simulatedPrice);
                    
                    const entryPrice = parseFloat(document.getElementById(`entryPrice${this.suffix}`).value);
                    const totalInvestment = parseFloat(document.getElementById(`investment${this.suffix}`).value);
                    const cryptoAllocationPercent = parseFloat(document.getElementById(`cryptoAllocation${this.suffix}`).value) || 57.96;
                    const priceChange = (simulatedPrice - entryPrice) / entryPrice;
                    
                    const cryptoAllocation = totalInvestment * (cryptoAllocationPercent / 100);
                    this.trendPnl = cryptoAllocation * priceChange;
                    
                    this.totalProfit = this.gridProfit + this.trendPnl;
                    this.profits.push(this.totalProfit);
                    
                    this.historicalIndex++;
                    
                    const currentPriceElement = document.getElementById(`currentPrice${this.suffix}`);
                    if (currentPriceElement) {
                        currentPriceElement.textContent = 
                            `${simulatedPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} USDT`;
                    }
                } else {
                    this.stopBot();
                    this.showMessage('Simulaci√≥n completada con datos hist√≥ricos', 'success');
                }
            }

            processGridOrders(currentPrice) {
                if (this.lastPrice === 0) {
                    this.lastPrice = currentPrice;
                    return;
                }

                this.gridLevels.forEach((level, index) => {
                    const crossedUp = this.lastPrice < level.price && currentPrice >= level.price;
                    const crossedDown = this.lastPrice > level.price && currentPrice <= level.price;
                    
                    if (crossedUp) {
                        this.executeSellOrder(level, currentPrice);
                    }
                    
                    if (crossedDown) {
                        this.executeBuyOrder(level, currentPrice);
                    }
                });

                this.lastPrice = currentPrice;
            }

            executeSellOrder(level, currentPrice) {
                const sellPrice = level.price;
                const cryptoQuantity = level.cryptoQuantity;
                const usdtReceived = sellPrice * cryptoQuantity;
                
                const tradingFee = usdtReceived * 0.002;
                const netUsdtReceived = usdtReceived - tradingFee;
                
                const matchingBuy = this.findMatchingBuyOrder(level.price);
                let gridProfit = 0;
                
                if (matchingBuy) {
                    gridProfit = (sellPrice - matchingBuy.price) * cryptoQuantity - tradingFee - matchingBuy.fee;
                    this.completedRounds++;
                } else {
                    gridProfit = netUsdtReceived - (cryptoQuantity * this.getInitialCryptoPrice());
                }
                
                this.gridProfit += Math.max(0, gridProfit);
                
                const symbol = document.getElementById(`symbol${this.suffix}`).value.replace('USDT', '');
                
                this.gridExecutions.push({
                    type: 'SELL',
                    price: sellPrice,
                    cryptoQuantity: cryptoQuantity,
                    usdtAmount: netUsdtReceived,
                    fee: tradingFee,
                    profit: gridProfit,
                    time: new Date(),
                    symbol: symbol
                });
            }

            executeBuyOrder(level, currentPrice) {
                const buyPrice = level.price;
                const cryptoQuantity = level.cryptoQuantity;
                const usdtSpent = buyPrice * cryptoQuantity;
                
                const tradingFee = usdtSpent * 0.002;
                const totalUsdtCost = usdtSpent + tradingFee;
                
                const symbol = document.getElementById(`symbol${this.suffix}`).value.replace('USDT', '');
                
                this.gridExecutions.push({
                    type: 'BUY',
                    price: buyPrice,
                    cryptoQuantity: cryptoQuantity,
                    usdtAmount: totalUsdtCost,
                    fee: tradingFee,
                    profit: 0,
                    time: new Date(),
                    symbol: symbol
                });
            }

            findMatchingBuyOrder(sellPrice) {
                const buyOrders = this.gridExecutions.filter(exec => 
                    exec.type === 'BUY' && exec.price < sellPrice
                ).reverse();
                
                return buyOrders.length > 0 ? buyOrders[0] : null;
            }

            getInitialCryptoPrice() {
                return parseFloat(document.getElementById(`entryPrice${this.suffix}`).value) || this.currentPrice;
            }

            updateChart() {
                if (!this.priceChart || this.priceHistory.length === 0) return;

                const labels = this.priceHistory.map(item => 
                    item.time.toLocaleTimeString('es-ES', { 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit' 
                    })
                );
                
                const priceData = this.priceHistory.map(item => item.price);
                const profitData = this.profits.map(profit => profit);

                this.priceChart.data.labels = labels;
                this.priceChart.data.datasets[0].data = priceData;
                this.priceChart.data.datasets[1].data = profitData;
                this.priceChart.update('none');
            }

            updateDisplay() {
                const profitElement = document.getElementById(`totalProfit${this.suffix}`);
                const percentageElement = document.getElementById(`profitPercentage${this.suffix}`);
                const investment = parseFloat(document.getElementById(`investment${this.suffix}`).value);
                
                const profitPercentage = (this.totalProfit / investment) * 100;
                const sign = this.totalProfit >= 0 ? '+' : '';
                
                if (profitElement) profitElement.textContent = `${sign}${this.totalProfit.toFixed(2)} USDT`;
                if (percentageElement) percentageElement.textContent = `(${sign}${profitPercentage.toFixed(2)}%)`;
                
                const profitDisplay = document.querySelector('#spot-grid .profit-display');
                if (profitDisplay) {
                    if (this.totalProfit >= 0) {
                        profitDisplay.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    } else {
                        profitDisplay.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                    }
                }

                const elements = {
                    [`gridProfit${this.suffix}`]: `+${this.gridProfit.toFixed(2)} USDT`,
                    [`trendPnl${this.suffix}`]: `${this.trendPnl >= 0 ? '+' : ''}${this.trendPnl.toFixed(2)} USDT`,
                    [`completedRounds${this.suffix}`]: this.completedRounds,
                    [`totalExecutions${this.suffix}`]: this.gridExecutions.length,
                    [`botStatus${this.suffix}`]: this.isRunning ? 'Activo' : 'Inactivo'
                };

                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                this.updateExecutionsList();
            }

            updateExecutionsList() {
                const executionsList = document.getElementById(`executionsList${this.suffix}`);
                const executionsCard = document.getElementById(`executionsCard${this.suffix}`);
                const progressFill = document.getElementById(`progressFill${this.suffix}`);
                
                if (progressFill && this.historicalData && this.historicalData.length > 0) {
                    const progress = (this.historicalIndex / this.historicalData.length) * 100;
                    progressFill.style.width = `${progress}%`;
                }
                
                if (executionsList && executionsCard) {
                    if (this.gridExecutions.length > 0) {
                        executionsCard.style.display = 'block';
                        
                        const lastExecutions = this.gridExecutions.slice(-5).reverse();
                        executionsList.innerHTML = lastExecutions.map(exec => `
                            <div class="execution-item">
                                <div>
                                    <span class="execution-type ${exec.type === 'BUY' ? 'execution-buy' : 'execution-sell'}">${exec.type}</span>
                                    <span>${exec.cryptoQuantity.toFixed(6)} ${exec.symbol} @ ${exec.price.toFixed(0)}</span>
                                </div>
                                <div style="color: ${exec.profit > 0 ? '#2ecc71' : '#bdc3c7'}; font-weight: bold;">
                                    ${exec.profit > 0 ? '+' : ''}${exec.profit.toFixed(2)} USDT
                                </div>
                            </div>
                        `).join('');
                    } else if (this.isRunning) {
                        executionsCard.style.display = 'block';
                        executionsList.innerHTML = '<div style="text-align: center; color: #bdc3c7; padding: 20px;">Esperando ejecuciones...</div>';
                    } else {
                        executionsCard.style.display = 'none';
                    }
                }
            }

            updateButtonStates() {
                const startBtn = document.getElementById(`startBot${this.suffix}`);
                const stopBtn = document.getElementById(`stopBot${this.suffix}`);
                
                if (!startBtn || !stopBtn) return;
                
                const startIndicator = startBtn.querySelector('.status-indicator');
                const stopIndicator = stopBtn.querySelector('.status-indicator');

                if (this.isRunning) {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    if (startIndicator) startIndicator.className = 'status-indicator status-active';
                    if (stopIndicator) stopIndicator.className = 'status-indicator status-inactive';
                    startBtn.innerHTML = '<span class="status-indicator status-active"></span> Bot Activo';
                } else {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    if (startIndicator) startIndicator.className = 'status-indicator status-inactive';
                    if (stopIndicator) stopIndicator.className = 'status-indicator status-inactive';
                    startBtn.innerHTML = '<span class="status-indicator status-inactive"></span> Iniciar Bot';
                }
            }

            showMessage(message, type) {
                const messageArea = document.getElementById(`messageArea${this.suffix}`);
                if (messageArea) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = type;
                    messageDiv.textContent = message;
                    
                    messageArea.innerHTML = '';
                    messageArea.appendChild(messageDiv);
                    
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 5000);
                }
            }
        }

        // Futures Grid Trading Bot (Modified from original)
        class FuturesGridTradingBot {
            constructor() {
                this.isRunning = false;
                this.currentPrice = 0;
                this.priceHistory = [];
                this.profits = [];
                this.totalProfit = 0;
                this.gridProfit = 0;
                this.unrealizedPnl = 0;
                this.completedTrades = 0;
                this.gridLevels = [];
                this.priceChart = null;
                this.updateInterval = null;
                this.simulationSpeed = 200;
                this.historicalData = null;
                this.historicalIndex = 0;
                this.lastPrice = 0;
                this.gridExecutions = [];
                this.fundingFeeInterval = null;
                this.totalFundingFees = 0;
                this.lastFundingTime = 0;
                this.mode = 'long';
                this.leverage = 10;
                this.margin = 0;
                this.positionSize = 0;
                this.averageEntryPrice = 0;
                this.openPositions = [];
                this.liquidationPrice = 0;
                this.cryptoPercentage = 50;
                this.usdtPercentage = 50;
                this.cryptoAllocation = 0;
                this.usdtAllocation = 0;
                this.gridOrders = [];
                this.suffix = '-futures';
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.initializeChart();
                this.setDefaultDates();
                this.updateAllocationCalculations();
                this.updateGridCalculations();
                this.getCurrentPrice();
                this.updateModeInfo();
                this.updateSymbolDisplay();
            }

            setupEventListeners() {
                document.getElementById(`startBot${this.suffix}`).addEventListener('click', () => this.startBot());
                document.getElementById(`stopBot${this.suffix}`).addEventListener('click', () => this.stopBot());
                
                ['maxPrice', 'minPrice', 'gridCount', 'investment'].forEach(id => {
                    const element = document.getElementById(`${id}${this.suffix}`);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.updateAllocationCalculations();
                            this.updateGridCalculations();
                        });
                    }
                });

                const cryptoPercentageElement = document.getElementById(`cryptoPercentage${this.suffix}`);
                if (cryptoPercentageElement) {
                    cryptoPercentageElement.addEventListener('input', (e) => {
                        this.handleAllocationChange('crypto', parseInt(e.target.value));
                    });
                }

                const usdtPercentageElement = document.getElementById(`usdtPercentage${this.suffix}`);
                if (usdtPercentageElement) {
                    usdtPercentageElement.addEventListener('input', (e) => {
                        this.handleAllocationChange('usdt', parseInt(e.target.value));
                    });
                }

                const symbolElement = document.getElementById(`symbol${this.suffix}`);
                if (symbolElement) {
                    symbolElement.addEventListener('change', () => {
                        this.getCurrentPrice();
                        this.updateGridCalculations();
                        this.updateSymbolDisplay();
                        this.updateAllocationCalculations();
                    });
                }

                document.querySelectorAll('#futures-grid .mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#futures-grid .mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.mode = btn.dataset.mode;
                        this.updateModeInfo();
                        this.updateGridCalculations();
                    });
                });

                document.querySelectorAll('#futures-grid .leverage-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#futures-grid .leverage-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.leverage = parseInt(btn.dataset.leverage);
                        this.updateGridCalculations();
                    });
                });
            }

            updateSymbolDisplay() {
                const symbolElement = document.getElementById(`symbol${this.suffix}`);
                const symbol = symbolElement ? symbolElement.value : 'BTCUSDT';
                const cryptoSymbol = symbol.replace('USDT', '');
                const cryptoSymbolElement = document.getElementById(`cryptoSymbol${this.suffix}`);
                if (cryptoSymbolElement) {
                    cryptoSymbolElement.textContent = cryptoSymbol;
                }
                this.updateAllocationCalculations();
            }

            handleAllocationChange(type, value) {
                if (value < 0) value = 0;
                if (value > 100) value = 100;
                
                if (type === 'crypto') {
                    this.cryptoPercentage = value;
                    this.usdtPercentage = 100 - value;
                    const usdtElement = document.getElementById(`usdtPercentage${this.suffix}`);
                    if (usdtElement) usdtElement.value = this.usdtPercentage;
                } else {
                    this.usdtPercentage = value;
                    this.cryptoPercentage = 100 - value;
                    const cryptoElement = document.getElementById(`cryptoPercentage${this.suffix}`);
                    if (cryptoElement) cryptoElement.value = this.cryptoPercentage;
                }
                
                this.updateAllocationCalculations();
                this.updateGridCalculations();
            }

            updateAllocationCalculations() {
                const totalMargin = parseFloat(document.getElementById(`investment${this.suffix}`).value) || 0;
                const symbolElement = document.getElementById(`symbol${this.suffix}`);
                const symbol = symbolElement ? symbolElement.value : 'BTCUSDT';
                const cryptoSymbol = symbol.replace('USDT', '');
                
                this.cryptoAllocation = (totalMargin * this.cryptoPercentage) / 100;
                this.usdtAllocation = (totalMargin * this.usdtPercentage) / 100;
                
                const allocationInfo = document.getElementById(`allocationInfo${this.suffix}`);
                if (allocationInfo) {
                    allocationInfo.innerHTML = `
                        üìä Asignaci√≥n: ${this.cryptoPercentage}% ${cryptoSymbol} (~${this.cryptoAllocation.toFixed(0)} USDT) + 
                        ${this.usdtPercentage}% USDT (${this.usdtAllocation.toFixed(0)} USDT)
                    `;
                }

                const currentAllocation = document.getElementById(`currentAllocation${this.suffix}`);
                if (currentAllocation) {
                    currentAllocation.textContent = `${this.cryptoPercentage}% ${cryptoSymbol} + ${this.usdtPercentage}% USDT`;
                }
            }

            updateModeInfo() {
                const modeInfo = document.getElementById(`modeInfo${this.suffix}`);
                const modes = {
                    neutral: '<strong>NEUTRAL:</strong> Sin posici√≥n inicial. Alterna entre long y short seg√∫n movimiento del precio.',
                    long: '<strong>LONG:</strong> Adecuado para mercados alcistas vol√°tiles. Inicia con posici√≥n larga.',
                    short: '<strong>SHORT:</strong> Adecuado para mercados bajistas vol√°tiles. Inicia con posici√≥n corta.'
                };
                if (modeInfo) {
                    modeInfo.innerHTML = modes[this.mode];
                }
            }

            setDefaultDates() {
                const startDate = new Date('2025-08-20T10:00:00');
                const endDate = new Date();
                
                const startElement = document.getElementById(`startDate${this.suffix}`);
                const endElement = document.getElementById(`endDate${this.suffix}`);
                
                if (startElement) startElement.value = startDate.toISOString().slice(0, 16);
                if (endElement) endElement.value = endDate.toISOString().slice(0, 16);
            }

            updateGridCalculations() {
                const maxPrice = parseFloat(document.getElementById(`maxPrice${this.suffix}`).value);
                const minPrice = parseFloat(document.getElementById(`minPrice${this.suffix}`).value);
                const gridCount = parseInt(document.getElementById(`gridCount${this.suffix}`).value);
                const margin = parseFloat(document.getElementById(`investment${this.suffix}`).value);

                if (maxPrice <= minPrice) {
                    this.showMessage('El precio superior debe ser mayor al inferior', 'error');
                    return;
                }

                const priceRange = maxPrice - minPrice;
                const gridInterval = priceRange / (gridCount - 1);
                const entryPrice = parseFloat(document.getElementById(`entryPrice${this.suffix}`).value) || ((maxPrice + minPrice) / 2);
                
                const availableMarginPerGrid = margin / gridCount;
                const positionSizePerGrid = (availableMarginPerGrid * this.leverage) / entryPrice;
                
                const tradingAmountElement = document.getElementById(`tradingAmount${this.suffix}`);
                if (tradingAmountElement) {
                    tradingAmountElement.value = availableMarginPerGrid.toFixed(2);
                }
                
                this.calculateLiquidationPrice(entryPrice, margin);
                
                const elements = {
                    [`tradingRange${this.suffix}`]: `${minPrice.toLocaleString()} - ${maxPrice.toLocaleString()}`,
                    [`gridInterval${this.suffix}`]: `${gridInterval.toFixed(2)} USDT`,
                    [`positionPerGrid${this.suffix}`]: `${positionSizePerGrid.toFixed(6)} BTC`,
                    [`currentMode${this.suffix}`]: this.mode.toUpperCase(),
                    [`currentLeverage${this.suffix}`]: `${this.leverage}x`
                };

                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                this.gridLevels = [];
                for (let i = 0; i < gridCount; i++) {
                    const price = minPrice + (i * gridInterval);
                    this.gridLevels.push({
                        price: price,
                        positionSize: positionSizePerGrid,
                        margin: availableMarginPerGrid,
                        filled: false
                    });
                }

                this.margin = margin;
                this.gridInterval = gridInterval;
            }

            calculateLiquidationPrice(entryPrice, margin) {
                const maintenanceMarginRate = 0.005;
                const fees = 0.001;
                
                let liquidationPrice;
                if (this.mode === 'long') {
                    liquidationPrice = entryPrice * (1 - (1/this.leverage) + maintenanceMarginRate + fees);
                } else if (this.mode === 'short') {
                    liquidationPrice = entryPrice * (1 + (1/this.leverage) + maintenanceMarginRate + fees);
                } else {
                    liquidationPrice = entryPrice;
                }
                
                this.liquidationPrice = liquidationPrice;
                const liquidationElement = document.getElementById(`liquidationPrice${this.suffix}`);
                if (liquidationElement) {
                    liquidationElement.textContent = liquidationPrice.toFixed(2) + ' USDT';
                    
                    if (Math.abs(this.currentPrice - liquidationPrice) / this.currentPrice < 0.1) {
                        liquidationElement.style.color = '#e74c3c';
                    } else if (Math.abs(this.currentPrice - liquidationPrice) / this.currentPrice < 0.2) {
                        liquidationElement.style.color = '#f39c12';
                    } else {
                        liquidationElement.style.color = '#2ecc71';
                    }
                }
            }

            async getCurrentPrice() {
                try {
                    const symbolElement = document.getElementById(`symbol${this.suffix}`);
                    const symbol = symbolElement ? symbolElement.value : 'BTCUSDT';
                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
                    const data = await response.json();
                    
                    // Update connection status
                    this.updateConnectionStatus(true);
                    
                    this.currentPrice = parseFloat(data.price);
                    const currentPriceElement = document.getElementById(`currentPrice${this.suffix}`);
                    if (currentPriceElement) {
                        currentPriceElement.textContent = 
                            `${this.currentPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} USDT`;
                    }
                    
                    if (!this.isRunning) {
                        const entryPriceElement = document.getElementById(`entryPrice${this.suffix}`);
                        if (entryPriceElement) {
                            entryPriceElement.value = this.currentPrice;
                        }
                    }
                    
                    this.updateAllocationCalculations();
                    this.updateGridCalculations();
                } catch (error) {
                    this.updateConnectionStatus(false);
                    this.showMessage('Error al obtener precio actual: ' + error.message, 'error');
                }
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    if (connected) {
                        statusElement.innerHTML = 'üü¢ Conectado';
                        statusElement.style.color = '#2ecc71';
                    } else {
                        statusElement.innerHTML = 'üî¥ Error de Conexi√≥n';
                        statusElement.style.color = '#e74c3c';
                    }
                }
            }

            initializeChart() {
                const ctx = document.getElementById(`priceChart${this.suffix}`);
                if (!ctx) return;
                
                this.priceChart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Precio',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4
                        }, {
                            label: 'PnL Total',
                            data: [],
                            borderColor: '#2ecc71',
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#ecf0f1'
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                ticks: { color: '#2ecc71' },
                                grid: { drawOnChartArea: false }
                            }
                        }
                    }
                });
            }

            async startBot() {
                if (this.isRunning) return;

                try {
                    this.validateInputs();
                    this.showMessage('Cargando datos hist√≥ricos...', 'success');
                    
                    await this.loadHistoricalData();
                    
                    this.isRunning = true;
                    this.updateButtonStates();
                    this.resetSimulation();
                    this.initializeGridOrders();
                    this.startHistoricalSimulation();
                    this.startFundingFeeTimer();
                    
                    const symbol = document.getElementById(`symbol${this.suffix}`).value.replace('USDT', '');
                    this.showMessage(
                        `Bot iniciado - Modo ${this.mode.toUpperCase()} con ${this.leverage}x leverage | Asignaci√≥n: ${this.cryptoPercentage}% ${symbol} + ${this.usdtPercentage}% USDT`, 
                        'success'
                    );
                } catch (error) {
                    this.showMessage('Error al iniciar bot: ' + error.message, 'error');
                    this.isRunning = false;
                    this.updateButtonStates();
                }
            }

            validateInputs() {
                const maxPrice = parseFloat(document.getElementById(`maxPrice${this.suffix}`).value);
                const minPrice = parseFloat(document.getElementById(`minPrice${this.suffix}`).value);
                const investment = parseFloat(document.getElementById(`investment${this.suffix}`).value);
                const gridCount = parseInt(document.getElementById(`gridCount${this.suffix}`).value);

                if (maxPrice <= minPrice) throw new Error('Precio superior debe ser mayor al inferior');
                if (investment < 10) throw new Error('Margen m√≠nimo: 10 USDT');
                if (gridCount < 2) throw new Error('M√≠nimo 2 rejillas');
                if (gridCount > 50) throw new Error('M√°ximo 50 rejillas');
                
                if (this.cryptoPercentage + this.usdtPercentage !== 100) {
                    throw new Error('La suma de los porcentajes debe ser 100%');
                }
                if (this.cryptoPercentage < 0 || this.usdtPercentage < 0) {
                    throw new Error('Los porcentajes no pueden ser negativos');
                }
            }

            resetSimulation() {
                this.totalProfit = 0;
                this.gridProfit = 0;
                this.unrealizedPnl = 0;
                this.completedTrades = 0;
                this.priceHistory = [];
                this.profits = [];
                this.gridExecutions = [];
                this.openPositions = [];
                this.totalFundingFees = 0;
                this.lastPrice = 0;
                this.historicalIndex = 0;
                this.gridOrders = [];
                this.updateDisplay();
                
                if (this.priceChart) {
                    this.priceChart.data.labels = [];
                    this.priceChart.data.datasets[0].data = [];
                    this.priceChart.data.datasets[1].data = [];
                    this.priceChart.update();
                }
            }

            async loadHistoricalData() {
                const symbolElement = document.getElementById(`symbol${this.suffix}`);
                const startDateElement = document.getElementById(`startDate${this.suffix}`);
                const endDateElement = document.getElementById(`endDate${this.suffix}`);
                
                const symbol = symbolElement ? symbolElement.value : 'BTCUSDT';
                const startDate = startDateElement ? startDateElement.value : '';
                const endDate = endDateElement ? endDateElement.value : '';
                
                if (!startDate || !endDate) {
                    throw new Error('Por favor selecciona fechas v√°lidas');
                }

                const startTime = new Date(startDate).getTime();
                const endTime = new Date(endDate).getTime();
                
                if (startTime >= endTime) {
                    throw new Error('La fecha de inicio debe ser anterior a la fecha final');
                }

                try {
                    const response = await fetch(
                        `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=5m&startTime=${startTime}&endTime=${endTime}&limit=1000`
                    );
                    
                    if (!response.ok) {
                        throw new Error(`Error de API: ${response.status}`);
                    }
                    
                    this.historicalData = await response.json();
                    this.historicalIndex = 0;
                    
                    if (this.historicalData.length === 0) {
                        throw new Error('No se encontraron datos para el per√≠odo seleccionado');
                    }
                    
                    console.log(`Cargados ${this.historicalData.length} puntos de datos hist√≥ricos`);
                } catch (error) {
                    throw new Error(`Error al cargar datos hist√≥ricos: ${error.message}`);
                }
            }

            initializeGridOrders() {
                this.gridOrders = [];
                const maxPrice = parseFloat(document.getElementById(`maxPrice${this.suffix}`).value);
                const minPrice = parseFloat(document.getElementById(`minPrice${this.suffix}`).value);
                const gridCount = parseInt(document.getElementById(`gridCount${this.suffix}`).value);
                const margin = parseFloat(document.getElementById(`investment${this.suffix}`).value);
                
                const priceRange = maxPrice - minPrice;
                const gridInterval = priceRange / (gridCount - 1);
                const marginPerGrid = margin / gridCount;
                
                for (let i = 0; i < gridCount; i++) {
                    const price = minPrice + (i * gridInterval);
                    const positionSize = (marginPerGrid * this.leverage) / price;
                    
                    this.gridOrders.push({
                        id: i,
                        price: price,
                        positionSize: positionSize,
                        margin: marginPerGrid,
                        buyOrderActive: true,
                        sellOrderActive: false,
                        position: null,
                        availableCrypto: this.cryptoAllocation * this.leverage / gridCount / price,
                        availableUsdt: this.usdtAllocation / gridCount
                    });
                }
            }

            startHistoricalSimulation() {
                this.updateInterval = setInterval(() => {
                    if (!this.isRunning) return;

                    try {
                        this.simulateGridTrading();
                        
                        if (this.historicalIndex % 3 === 0) {
                            this.updateChart();
                            this.updateDisplay();
                        }
                    } catch (error) {
                        console.error('Simulation error:', error);
                        this.showMessage('Error en simulaci√≥n: ' + error.message, 'error');
                    }
                }, this.simulationSpeed);
            }

            startFundingFeeTimer() {
                this.fundingFeeInterval = setInterval(() => {
                    this.calculateFundingFee();
                }, 30000);
            }

            calculateFundingFee() {
                if (this.openPositions.length === 0) return;

                const fundingRate = (Math.random() - 0.5) * 0.00002;
                
                this.openPositions.forEach(position => {
                    const fundingFee = position.size * this.currentPrice * Math.abs(fundingRate);
                    this.totalFundingFees += fundingFee * (fundingRate > 0 ? -1 : 1);
                });

                const fundingElement = document.getElementById(`totalFundingFees${this.suffix}`);
                if (fundingElement) {
                    const sign = this.totalFundingFees >= 0 ? '+' : '';
                    fundingElement.textContent = `${sign}${this.totalFundingFees.toFixed(2)} USDT`;
                }
            }

            async simulateGridTrading() {
                if (this.historicalData && this.historicalIndex < this.historicalData.length) {
                    const currentData = this.historicalData[this.historicalIndex];
                    const simulatedPrice = parseFloat(currentData[4]);
                    
                    this.priceHistory.push({
                        time: new Date(currentData[6]),
                        price: simulatedPrice
                    });

                    this.processGridOrders(simulatedPrice);
                    this.calculateUnrealizedPnL(simulatedPrice);
                    
                    this.totalProfit = this.gridProfit + this.unrealizedPnl + this.totalFundingFees;
                    this.profits.push(this.totalProfit);
                    
                    this.historicalIndex++;
                    
                    const currentPriceElement = document.getElementById(`currentPrice${this.suffix}`);
                    if (currentPriceElement) {
                        currentPriceElement.textContent = 
                            `${simulatedPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} USDT`;
                    }
                } else {
                    this.stopBot();
                    this.showMessage('Simulaci√≥n completada con datos hist√≥ricos', 'success');
                }
            }

            processGridOrders(currentPrice) {
                this.gridOrders.forEach(order => {
                    if (order.buyOrderActive && currentPrice <= order.price && !order.position) {
                        if (this.canExecuteBuyOrder(order, currentPrice)) {
                            this.executeBuyOrder(order, currentPrice);
                        }
                    }
                    
                    if (order.sellOrderActive && currentPrice >= order.price && order.position) {
                        this.executeSellOrder(order, currentPrice);
                    }
                });
            }

            canExecuteBuyOrder(order, currentPrice) {
                return (order.availableUsdt > 0 || order.availableCrypto > 0);
            }

            executeBuyOrder(order, currentPrice) {
                const position = {
                    id: order.id,
                    type: this.mode === 'short' ? 'short' : 'long',
                    entryPrice: currentPrice,
                    size: order.positionSize,
                    margin: order.margin,
                    timestamp: Date.now()
                };
                
                order.position = position;
                this.openPositions.push(position);
                
                order.sellOrderActive = true;
                order.buyOrderActive = false;
                
                this.gridExecutions.push({
                    type: position.type === 'long' ? 'OPEN_LONG' : 'OPEN_SHORT',
                    price: currentPrice,
                    size: position.size,
                    profit: 0,
                    time: new Date()
                });
            }

            executeSellOrder(order, currentPrice) {
                const position = order.position;
                if (!position) return;
                
                let profit = this.calculateTradeProfit(position, currentPrice);
                
                this.gridProfit += profit;
                this.completedTrades++;
                
                const posIndex = this.openPositions.indexOf(position);
                if (posIndex > -1) {
                    this.openPositions.splice(posIndex, 1);
                }
                
                order.position = null;
                order.buyOrderActive = true;
                order.sellOrderActive = false;
                
                this.gridExecutions.push({
                    type: position.type === 'long' ? 'CLOSE_LONG' : 'CLOSE_SHORT',
                    price: currentPrice,
                    size: position.size,
                    profit: profit,
                    time: new Date()
                });
            }

            calculateTradeProfit(position, exitPrice) {
                let pnl = 0;
                
                if (position.type === 'long') {
                    pnl = (exitPrice - position.entryPrice) * position.size;
                } else {
                    pnl = (position.entryPrice - exitPrice) * position.size;
                }
                
                const tradingFees = (position.entryPrice * position.size + exitPrice * position.size) * 0.001;
                return pnl - tradingFees;
            }

            calculateUnrealizedPnL(currentPrice) {
                this.unrealizedPnl = 0;
                
                this.openPositions.forEach(position => {
                    if (position.type === 'long') {
                        this.unrealizedPnl += (currentPrice - position.entryPrice) * position.size;
                    } else {
                        this.unrealizedPnl += (position.entryPrice - currentPrice) * position.size;
                    }
                });
            }

            updateChart() {
                if (!this.priceChart || this.priceHistory.length === 0) return;

                const labels = this.priceHistory.map(item => 
                    item.time.toLocaleTimeString('es-ES', { 
                        hour: '2-digit', 
                        minute: '2-digit', 
                        second: '2-digit' 
                    })
                );
                
                const priceData = this.priceHistory.map(item => item.price);
                const profitData = this.profits.map(profit => profit);

                this.priceChart.data.labels = labels;
                this.priceChart.data.datasets[0].data = priceData;
                this.priceChart.data.datasets[1].data = profitData;
                this.priceChart.update('none');
            }

            updateDisplay() {
                const profitElement = document.getElementById(`totalProfit${this.suffix}`);
                const percentageElement = document.getElementById(`profitPercentage${this.suffix}`);
                const investment = parseFloat(document.getElementById(`investment${this.suffix}`).value);
                
                const profitPercentage = (this.totalProfit / investment) * 100;
                const sign = this.totalProfit >= 0 ? '+' : '';
                
                if (profitElement) profitElement.textContent = `${sign}${this.totalProfit.toFixed(2)} USDT`;
                if (percentageElement) percentageElement.textContent = `(${sign}${profitPercentage.toFixed(2)}%)`;
                
                const profitDisplay = document.querySelector('#futures-grid .profit-display');
                if (profitDisplay) {
                    if (this.totalProfit >= 0) {
                        profitDisplay.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    } else {
                        profitDisplay.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                    }
                }

                const elements = {
                    [`gridProfit${this.suffix}`]: `+${this.gridProfit.toFixed(2)} USDT`,
                    [`unrealizedPnl${this.suffix}`]: `${this.unrealizedPnl >= 0 ? '+' : ''}${this.unrealizedPnl.toFixed(2)} USDT`,
                    [`completedTrades${this.suffix}`]: this.completedTrades,
                    [`totalExecutions${this.suffix}`]: this.gridExecutions.length
                };

                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                this.updateExecutionsList();
            }

            updateExecutionsList() {
                const executionsList = document.getElementById(`executionsList${this.suffix}`);
                const executionsCard = document.getElementById(`executionsCard${this.suffix}`);
                const progressFill = document.getElementById(`progressFill${this.suffix}`);
                
                if (progressFill && this.historicalData && this.historicalData.length > 0) {
                    const progress = (this.historicalIndex / this.historicalData.length) * 100;
                    progressFill.style.width = `${progress}%`;
                }
                
                if (executionsList && executionsCard) {
                    if (this.gridExecutions.length > 0) {
                        executionsCard.style.display = 'block';
                        
                        const lastExecutions = this.gridExecutions.slice(-5).reverse();
                        executionsList.innerHTML = lastExecutions.map(exec => `
                            <div class="execution-item">
                                <div>
                                    <span class="execution-type ${exec.type.includes('LONG') ? 'execution-long' : 'execution-short'}">${exec.type}</span>
                                    <span>${exec.size.toFixed(6)} BTC @ ${exec.price.toFixed(0)}</span>
                                </div>
                                <div style="color: ${exec.profit > 0 ? '#2ecc71' : exec.profit < 0 ? '#e74c3c' : '#bdc3c7'}; font-weight: bold;">
                                    ${exec.profit !== 0 ? (exec.profit > 0 ? '+' : '') + exec.profit.toFixed(2) + ' USDT' : '--'}
                                </div>
                            </div>
                        `).join('');
                    } else if (this.isRunning) {
                        executionsCard.style.display = 'block';
                        executionsList.innerHTML = '<div style="text-align: center; color: #bdc3c7; padding: 20px;">Esperando ejecuciones...</div>';
                    } else {
                        executionsCard.style.display = 'none';
                    }
                }
            }

            stopBot() {
                this.isRunning = false;
                this.updateButtonStates();
                
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
                
                if (this.fundingFeeInterval) {
                    clearInterval(this.fundingFeeInterval);
                    this.fundingFeeInterval = null;
                }
                
                const totalExecutions = this.gridExecutions.length;
                const finalProfit = this.totalProfit;
                
                this.showMessage(
                    `Bot detenido - ${totalExecutions} ejecuciones, PnL: ${finalProfit >= 0 ? '+' : ''}${finalProfit.toFixed(2)} USDT`, 
                    finalProfit >= 0 ? 'success' : 'error'
                );
            }

            updateButtonStates() {
                const startBtn = document.getElementById(`startBot${this.suffix}`);
                const stopBtn = document.getElementById(`stopBot${this.suffix}`);
                
                if (!startBtn || !stopBtn) return;
                
                const startIndicator = startBtn.querySelector('.status-indicator');
                const stopIndicator = stopBtn.querySelector('.status-indicator');

                if (this.isRunning) {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    if (startIndicator) startIndicator.className = 'status-indicator status-active';
                    if (stopIndicator) stopIndicator.className = 'status-indicator status-inactive';
                    startBtn.innerHTML = '<span class="status-indicator status-active"></span> Bot Activo';
                } else {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    if (startIndicator) startIndicator.className = 'status-indicator status-inactive';
                    if (stopIndicator) stopIndicator.className = 'status-indicator status-inactive';
                    startBtn.innerHTML = '<span class="status-indicator status-inactive"></span> Iniciar Bot';
                }
            }

            showMessage(message, type) {
                const messageArea = document.getElementById(`messageArea${this.suffix}`);
                if (messageArea) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = type;
                    messageDiv.textContent = message;
                    
                    messageArea.innerHTML = '';
                    messageArea.appendChild(messageDiv);
                    
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 5000);
                }
            }
        }

        // Manual Spot Trading Class
        class ManualSpotTrader {
            constructor() {
                this.currentPrice = 0;
                this.usdtBalance = 1000.00;
                this.cryptoBalance = 0;
                this.totalValue = 1000.00;
                this.totalPnl = 0;
                this.totalTrades = 0;
                this.activePositions = [];
                this.tradeHistory = [];
                this.chart = null;
                this.priceHistory = [];
                this.orderType = 'buy';
                this.orderMode = 'limit';
                this.symbol = 'BTCUSDT';
                
                this.init();
            }

            init() {
                this.loadData(); // Load saved data first
                this.setupEventListeners();
                this.initializeChart();
                this.getCurrentPrice();
                this.updateDisplay();
                this.startPriceUpdates();
                this.setupAutoSave(); // Setup auto-save
            }

            startPriceUpdates() {
                // Update price every 3 seconds
                setInterval(() => {
                    this.getCurrentPrice();
                    this.checkStopLossTakeProfit();
                }, 3000);
            }

            setupEventListeners() {
                // Order type selector (Buy/Sell)
                document.querySelectorAll('#manual-spot .order-type-btn[data-type]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#manual-spot .order-type-btn[data-type]').forEach(b => {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        this.orderType = btn.dataset.type;
                        this.updateOrderButtons();
                    });
                });

                // Order mode selector (Market/Limit)
                document.querySelectorAll('#manual-spot .order-type-btn[data-order]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#manual-spot .order-type-btn[data-order]').forEach(b => {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        this.orderMode = btn.dataset.order;
                        this.updateOrderForm();
                    });
                });

                // Symbol change
                document.getElementById('symbol-manual-spot').addEventListener('change', () => {
                    this.symbol = document.getElementById('symbol-manual-spot').value;
                    this.getCurrentPrice();
                    this.updateSymbolDisplay();
                });

                // Price/Quantity changes
                document.getElementById('orderPrice-manual-spot').addEventListener('input', () => {
                    this.calculateTotal();
                });
                
                document.getElementById('orderQuantity-manual-spot').addEventListener('input', () => {
                    this.calculateTotal();
                });

                // Execute buttons
                document.getElementById('executeBuy-manual-spot').addEventListener('click', () => {
                    this.executeTrade('buy');
                });
                
                document.getElementById('executeSell-manual-spot').addEventListener('click', () => {
                    this.executeTrade('sell');
                });

                // Balance editor button
                document.getElementById('editBalanceSpot').addEventListener('click', () => {
                    this.editBalance();
                });

                // Advanced order buttons
                document.querySelectorAll('#manual-spot .advanced-order-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // Remove active class from all buttons
                        document.querySelectorAll('#manual-spot .advanced-order-btn').forEach(b => b.classList.remove('active'));
                        
                        // Add active class to clicked button
                        e.target.classList.add('active');
                        
                        // Show form for selected order type
                        const orderType = e.target.dataset.type;
                        this.showAdvancedOrderForm(orderType);
                    });
                });
            }

            async getCurrentPrice() {
                try {
                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${this.symbol}`);
                    const data = await response.json();
                    this.currentPrice = parseFloat(data.price);
                    
                    // Update connection status
                    this.updateConnectionStatus(true);
                    
                    // Update current price display
                    const priceDisplay = document.getElementById('currentPriceDisplay-manual-spot');
                    if (priceDisplay) {
                        priceDisplay.textContent = this.currentPrice.toLocaleString();
                    }
                    
                    // Update price in form
                    if (this.orderMode === 'market') {
                        document.getElementById('orderPrice-manual-spot').value = this.currentPrice;
                    }
                    
                    this.calculateTotal();
                    this.updatePositionValues();
                    this.updateDisplay(); // Update display when price changes
                    
                } catch (error) {
                    this.updateConnectionStatus(false);
                    this.showMessage('Error al obtener precio: ' + error.message, 'error');
                }
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    if (connected) {
                        statusElement.innerHTML = 'üü¢ Conectado';
                        statusElement.style.color = '#2ecc71';
                    } else {
                        statusElement.innerHTML = 'üî¥ Error de Conexi√≥n';
                        statusElement.style.color = '#e74c3c';
                    }
                }
            }

            calculateTotal() {
                const price = parseFloat(document.getElementById('orderPrice-manual-spot').value) || 0;
                const quantity = parseFloat(document.getElementById('orderQuantity-manual-spot').value) || 0;
                const total = price * quantity;
                
                document.getElementById('orderTotal-manual-spot').value = total.toFixed(2);
            }

            updateSymbolDisplay() {
                const cryptoSymbol = this.symbol.replace('USDT', '');
                document.getElementById('buySymbol-manual-spot').textContent = cryptoSymbol;
                document.getElementById('sellSymbol-manual-spot').textContent = cryptoSymbol;
                this.updateDisplay();
            }

            updateOrderButtons() {
                const buyBtn = document.getElementById('executeBuy-manual-spot');
                const sellBtn = document.getElementById('executeSell-manual-spot');
                
                if (this.orderType === 'buy') {
                    buyBtn.disabled = false;
                    sellBtn.disabled = true;
                } else {
                    buyBtn.disabled = true;
                    sellBtn.disabled = false;
                }
            }

            updateOrderForm() {
                const priceInput = document.getElementById('orderPrice-manual-spot');
                if (this.orderMode === 'market') {
                    priceInput.value = this.currentPrice;
                    priceInput.disabled = true;
                } else {
                    priceInput.disabled = false;
                }
            }

            executeTrade(type) {
                const price = parseFloat(document.getElementById('orderPrice-manual-spot').value) || 0;
                const quantity = parseFloat(document.getElementById('orderQuantity-manual-spot').value) || 0;
                const total = price * quantity;
                const fee = total * 0.001; // 0.1% fee
                const stopLoss = parseFloat(document.getElementById('stopLoss-manual-spot').value) || 0;
                const takeProfit = parseFloat(document.getElementById('takeProfit-manual-spot').value) || 0;

                if (type === 'buy') {
                    if (this.usdtBalance < total + fee) {
                        this.showMessage('Balance insuficiente para la compra', 'error');
                        return;
                    }
                    
                    // Execute buy order
                    this.usdtBalance -= (total + fee);
                    this.cryptoBalance += quantity;
                    
                    // Create position with stop loss and take profit
                    const position = {
                        id: Date.now(),
                        type: 'long',
                        symbol: this.symbol,
                        entryPrice: price,
                        quantity: quantity,
                        value: total,
                        fee: fee,
                        stopLoss: stopLoss > 0 ? price * (1 - stopLoss / 100) : null,
                        takeProfit: takeProfit > 0 ? price * (1 + takeProfit / 100) : null,
                        timestamp: new Date()
                    };
                    
                    this.activePositions.push(position);
                    this.showMessage(`Compra ejecutada: ${quantity} ${this.symbol.replace('USDT', '')} a $${price}`, 'success');
                    
                } else if (type === 'sell') {
                    if (this.cryptoBalance < quantity) {
                        this.showMessage('Balance insuficiente para la venta', 'error');
                        return;
                    }
                    
                    // Execute sell order
                    this.cryptoBalance -= quantity;
                    this.usdtBalance += (total - fee);
                    
                    // Remove from positions or reduce quantity
                    this.closePosition(quantity, price);
                    this.showMessage(`Venta ejecutada: ${quantity} ${this.symbol.replace('USDT', '')} a $${price}`, 'success');
                }

                this.totalTrades++;
                this.updateDisplay();
                this.checkStopLossTakeProfit();
                this.saveData(); // Save after trade execution
            }

            closePosition(quantity, price) {
                // Find and close positions
                let remainingQuantity = quantity;
                const cryptoSymbol = this.symbol.replace('USDT', '');
                
                for (let i = this.activePositions.length - 1; i >= 0 && remainingQuantity > 0; i--) {
                    const position = this.activePositions[i];
                    if (position.symbol === this.symbol) {
                        const closeQuantity = Math.min(remainingQuantity, position.quantity);
                        const pnl = (price - position.entryPrice) * closeQuantity - position.fee * (closeQuantity / position.quantity);
                        
                        this.totalPnl += pnl;
                        position.quantity -= closeQuantity;
                        remainingQuantity -= closeQuantity;
                        
                        if (position.quantity <= 0) {
                            this.activePositions.splice(i, 1);
                        }
                        
                        this.tradeHistory.push({
                            type: 'close',
                            symbol: cryptoSymbol,
                            quantity: closeQuantity,
                            entryPrice: position.entryPrice,
                            exitPrice: price,
                            pnl: pnl,
                            timestamp: new Date()
                        });
                    }
                }
            }

            checkStopLossTakeProfit() {
                // Check if any positions hit stop loss or take profit
                // Use a copy of the array to avoid issues with concurrent modification
                const positionsToCheck = [...this.activePositions];
                
                positionsToCheck.forEach((position, index) => {
                    if (position.stopLoss && this.currentPrice <= position.stopLoss) {
                        // Execute stop loss
                        this.executeTrade('sell');
                        this.showMessage(`Stop Loss activado para ${position.symbol}`, 'warning');
                    }
                    
                    if (position.takeProfit && this.currentPrice >= position.takeProfit) {
                        // Execute take profit
                        this.executeTrade('sell');
                        this.showMessage(`Take Profit activado para ${position.symbol}`, 'success');
                    }
                });

                // Check advanced orders
                this.checkAdvancedOrders();
            }

            checkAdvancedOrders() {
                if (!this.advancedOrders) return;

                this.advancedOrders.forEach(order => {
                    if (order.status !== 'active') return;

                    switch (order.type) {
                        case 'trailing-stop':
                            this.processTrailingStop(order);
                            break;
                        case 'oco':
                            this.processOCOOrder(order);
                            break;
                        case 'scale-in':
                            this.processScaleInOrder(order);
                            break;
                        case 'scale-out':
                            this.processScaleOutOrder(order);
                            break;
                    }
                });

                // Remove completed orders
                this.advancedOrders = this.advancedOrders.filter(order => order.status === 'active');
            }

            processTrailingStop(order) {
                // Update highest price and adjust stop
                if (this.currentPrice > order.highestPrice) {
                    order.highestPrice = this.currentPrice;
                    order.currentStopPrice = this.currentPrice * (1 - order.distance / 100);
                }
                
                // Check if stop triggered
                if (this.currentPrice <= order.currentStopPrice) {
                    // Execute the trailing stop
                    if (order.amount <= this.cryptoBalance) {
                        // Simulate sell execution
                        this.cryptoBalance -= order.amount;
                        this.usdtBalance += order.amount * this.currentPrice;
                        
                        this.tradeHistory.push({
                            symbol: this.symbol,
                            type: 'sell',
                            amount: order.amount,
                            price: this.currentPrice,
                            pnl: order.amount * (this.currentPrice - order.triggerPrice),
                            timestamp: new Date().toISOString(),
                            reason: 'trailing-stop'
                        });

                        order.status = 'executed';
                        this.showMessage(`üéØ Trailing Stop ejecutado: ${order.amount.toFixed(6)} ${this.symbol.replace('USDT', '')} a $${this.currentPrice.toLocaleString()}`, 'info');
                        this.updateDisplay();
                        this.saveData();
                    }
                }
            }

            processOCOOrder(order) {
                // Check take profit
                if (this.currentPrice >= order.takeProfitPrice) {
                    if (order.amount <= this.cryptoBalance) {
                        this.cryptoBalance -= order.amount;
                        this.usdtBalance += order.amount * order.takeProfitPrice;
                        
                        this.tradeHistory.push({
                            symbol: this.symbol,
                            type: 'sell',
                            amount: order.amount,
                            price: order.takeProfitPrice,
                            pnl: order.amount * (order.takeProfitPrice - order.takeProfitPrice), // Will be calculated properly
                            timestamp: new Date().toISOString(),
                            reason: 'oco-take-profit'
                        });

                        order.status = 'executed-tp';
                        this.showMessage(`‚öñÔ∏è OCO Take Profit ejecutado a $${order.takeProfitPrice.toLocaleString()}`, 'success');
                        this.updateDisplay();
                        this.saveData();
                    }
                }
                // Check stop loss
                else if (this.currentPrice <= order.stopLossPrice) {
                    if (order.amount <= this.cryptoBalance) {
                        this.cryptoBalance -= order.amount;
                        this.usdtBalance += order.amount * order.stopLossPrice;
                        
                        this.tradeHistory.push({
                            symbol: this.symbol,
                            type: 'sell',
                            amount: order.amount,
                            price: order.stopLossPrice,
                            pnl: order.amount * (order.stopLossPrice - order.stopLossPrice), // Will be calculated properly
                            timestamp: new Date().toISOString(),
                            reason: 'oco-stop-loss'
                        });

                        order.status = 'executed-sl';
                        this.showMessage(`‚öñÔ∏è OCO Stop Loss ejecutado a $${order.stopLossPrice.toLocaleString()}`, 'error');
                        this.updateDisplay();
                        this.saveData();
                    }
                }
            }

            processScaleInOrder(order) {
                const amountPerLevel = order.totalAmount / order.levels;
                
                for (let i = order.executedLevels; i < order.levels; i++) {
                    const targetPrice = order.basePrice * Math.pow(1 - order.reduction / 100, i);
                    
                    if (this.currentPrice <= targetPrice && amountPerLevel <= this.usdtBalance) {
                        // Execute this level
                        const cryptoAmount = amountPerLevel / this.currentPrice;
                        this.cryptoBalance += cryptoAmount;
                        this.usdtBalance -= amountPerLevel;
                        
                        this.tradeHistory.push({
                            symbol: this.symbol,
                            type: 'buy',
                            amount: cryptoAmount,
                            price: this.currentPrice,
                            pnl: 0,
                            timestamp: new Date().toISOString(),
                            reason: `scale-in-level-${i + 1}`
                        });

                        order.executedLevels++;
                        this.showMessage(`üìà Scale In Nivel ${i + 1} ejecutado: $${amountPerLevel.toFixed(2)} a $${this.currentPrice.toLocaleString()}`, 'success');
                        this.updateDisplay();
                        this.saveData();
                        
                        // Check if all levels executed
                        if (order.executedLevels >= order.levels) {
                            order.status = 'completed';
                            this.showMessage(`üìà Scale In completado: Todos los ${order.levels} niveles ejecutados`, 'success');
                        }
                        break; // Only execute one level per price check
                    }
                }
            }

            processScaleOutOrder(order) {
                const amountPerLevel = order.totalAmount / order.levels;
                
                for (let i = order.executedLevels; i < order.levels; i++) {
                    const targetPrice = order.basePrice * Math.pow(1 + order.increment / 100, i);
                    
                    if (this.currentPrice >= targetPrice && amountPerLevel <= this.cryptoBalance) {
                        // Execute this level
                        this.cryptoBalance -= amountPerLevel;
                        this.usdtBalance += amountPerLevel * this.currentPrice;
                        
                        this.tradeHistory.push({
                            symbol: this.symbol,
                            type: 'sell',
                            amount: amountPerLevel,
                            price: this.currentPrice,
                            pnl: amountPerLevel * (this.currentPrice - order.basePrice),
                            timestamp: new Date().toISOString(),
                            reason: `scale-out-level-${i + 1}`
                        });

                        order.executedLevels++;
                        this.showMessage(`üìâ Scale Out Nivel ${i + 1} ejecutado: ${amountPerLevel.toFixed(6)} ${this.symbol.replace('USDT', '')} a $${this.currentPrice.toLocaleString()}`, 'success');
                        this.updateDisplay();
                        this.saveData();
                        
                        // Check if all levels executed
                        if (order.executedLevels >= order.levels) {
                            order.status = 'completed';
                            this.showMessage(`üìâ Scale Out completado: Todos los ${order.levels} niveles ejecutados`, 'success');
                        }
                        break; // Only execute one level per price check
                    }
                }
            }

            updatePositionValues() {
                this.activePositions.forEach(position => {
                    position.currentValue = position.quantity * this.currentPrice;
                    position.unrealizedPnl = (this.currentPrice - position.entryPrice) * position.quantity - position.fee;
                });
            }

            updateDisplay() {
                // Update balances
                document.getElementById('spotBalance').textContent = `${this.usdtBalance.toFixed(2)} USDT`;
                document.getElementById('usdtBalance-manual-spot').textContent = `${this.usdtBalance.toFixed(2)} USDT`;
                
                const cryptoSymbol = this.symbol.replace('USDT', '');
                document.getElementById('cryptoBalance-manual-spot').textContent = `${this.cryptoBalance.toFixed(6)} ${cryptoSymbol}`;
                
                // Calculate total value
                this.totalValue = this.usdtBalance + (this.cryptoBalance * this.currentPrice);
                document.getElementById('totalValue-manual-spot').textContent = `${this.totalValue.toFixed(2)} USDT`;
                
                // Calculate total PnL
                const totalPnlPercent = ((this.totalValue - 1000) / 1000) * 100;
                document.getElementById('totalPnl-manual-spot').textContent = 
                    `${this.totalPnl >= 0 ? '+' : ''}${this.totalPnl.toFixed(2)} USDT (${totalPnlPercent >= 0 ? '+' : ''}${totalPnlPercent.toFixed(2)}%)`;
                
                document.getElementById('totalTrades-manual-spot').textContent = this.totalTrades;
                
                // Update active positions display
                this.updateActivePositions();
            }

            updateActivePositions() {
                const container = document.getElementById('activePositions-manual-spot');
                
                if (this.activePositions.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #bdc3c7; padding: 20px;">No hay posiciones activas</div>';
                    return;
                }
                
                container.innerHTML = this.activePositions.map(position => {
                    const pnl = (this.currentPrice - position.entryPrice) * position.quantity - position.fee;
                    const pnlPercent = (pnl / position.value) * 100;
                    const pnlClass = pnl >= 0 ? 'pnl-positive' : 'pnl-negative';
                    
                    return `
                        <div class="position-item">
                            <div>
                                <strong>${position.symbol.replace('USDT', '')}</strong><br>
                                ${position.quantity.toFixed(6)} @ $${position.entryPrice.toFixed(2)}
                            </div>
                            <div class="${pnlClass}">
                                ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}<br>
                                (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)
                                <br><button onclick="window.manualSpotTrader.closeIndividualPosition(${position.id})" 
                                          style="font-size: 10px; padding: 2px 6px; margin-top: 4px; background: #e74c3c; border: none; border-radius: 3px; color: white; cursor: pointer;">
                                    Cerrar
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            initializeChart() {
                const ctx = document.getElementById('spotChart-manual');
                if (!ctx) return;
                
                this.chart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Precio',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#ecf0f1' }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            }
                        }
                    }
                });

                // Update chart periodically
                setInterval(() => {
                    this.updateChart();
                    this.updateTechnicalIndicators();
                }, 5000);
            }

            updateTechnicalIndicators() {
                if (this.priceHistory.length > 0) {
                    TechnicalIndicators.updateIndicators('spot', this.currentPrice, this.priceHistory);
                }
            }

            updateChart() {
                if (!this.chart) return;

                this.priceHistory.push({
                    time: new Date(),
                    price: this.currentPrice
                });

                // Keep only last 20 points
                if (this.priceHistory.length > 20) {
                    this.priceHistory.shift();
                }

                const labels = this.priceHistory.map(item => 
                    item.time.toLocaleTimeString('es-ES', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    })
                );
                
                const data = this.priceHistory.map(item => item.price);

                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = data;
                this.chart.update('none');
            }

            editBalance() {
                const currentBalance = this.usdtBalance + (this.cryptoBalance * this.currentPrice);
                const newBalance = prompt(`Ingresa el nuevo balance total (USDT):\n\nBalance actual: ${currentBalance.toFixed(2)} USDT`, currentBalance.toFixed(2));
                
                if (newBalance !== null && !isNaN(newBalance) && parseFloat(newBalance) > 0) {
                    const balanceValue = parseFloat(newBalance);
                    
                    // Reset balances
                    const cryptoValue = this.cryptoBalance * this.currentPrice;
                    this.usdtBalance = balanceValue - cryptoValue;
                    
                    // If negative USDT balance, convert some crypto to USDT
                    if (this.usdtBalance < 0) {
                        this.cryptoBalance = 0;
                        this.usdtBalance = balanceValue;
                    }
                    
                                    this.totalValue = balanceValue;
                this.updateDisplay();
                this.saveData(); // Save after balance edit
                this.showMessage(`Balance actualizado a ${balanceValue.toFixed(2)} USDT`, 'success');
                } else if (newBalance !== null) {
                    this.showMessage('Por favor ingresa un valor v√°lido mayor a 0', 'error');
                }
            }

            // ===== ADVANCED ORDERS FUNCTIONALITY =====
            showAdvancedOrderForm(orderType) {
                const formContainer = document.getElementById('advancedOrderForm-spot');
                if (!formContainer) return;

                formContainer.style.display = 'block';
                
                let formHTML = '';
                switch (orderType) {
                    case 'trailing-stop':
                        formHTML = this.createTrailingStopForm();
                        break;
                    case 'oco':
                        formHTML = this.createOCOForm();
                        break;
                    case 'scale-in':
                        formHTML = this.createScaleInForm();
                        break;
                    case 'scale-out':
                        formHTML = this.createScaleOutForm();
                        break;
                    default:
                        formContainer.style.display = 'none';
                        return;
                }
                
                formContainer.innerHTML = formHTML;
                this.setupAdvancedOrderListeners(orderType);
            }

            createTrailingStopForm() {
                return `
                    <div class="advanced-form">
                        <h5>üéØ Trailing Stop Configuration</h5>
                        <div class="form-group">
                            <label>Cantidad (${this.symbol.replace('USDT', '')})</label>
                            <input type="number" id="trailing-amount" step="0.001" placeholder="0.001" max="${this.cryptoBalance}">
                            <small>Disponible: ${this.cryptoBalance.toFixed(6)} ${this.symbol.replace('USDT', '')}</small>
                        </div>
                        <div class="form-group">
                            <label>Trail Distance (%)</label>
                            <input type="number" id="trailing-distance" value="2" step="0.1" min="0.1" max="10">
                            <small>Distancia en % que seguir√° el precio</small>
                        </div>
                        <button class="execute-btn" id="createTrailingStop">üéØ Crear Trailing Stop</button>
                        <button class="cancel-btn" onclick="document.getElementById('advancedOrderForm-spot').style.display='none'">‚ùå Cancelar</button>
                    </div>
                `;
            }

            createOCOForm() {
                const profitPrice = (this.currentPrice * 1.05).toFixed(2);
                const lossPrice = (this.currentPrice * 0.95).toFixed(2);
                return `
                    <div class="advanced-form">
                        <h5>‚öñÔ∏è OCO Order Configuration</h5>
                        <div class="form-group">
                            <label>Cantidad (${this.symbol.replace('USDT', '')})</label>
                            <input type="number" id="oco-amount" step="0.001" placeholder="0.001" max="${this.cryptoBalance}">
                            <small>Disponible: ${this.cryptoBalance.toFixed(6)} ${this.symbol.replace('USDT', '')}</small>
                        </div>
                        <div class="form-group">
                            <label>üü¢ Take Profit Price ($)</label>
                            <input type="number" id="oco-take-profit" step="0.01" value="${profitPrice}">
                            <small>Precio de ganancia objetivo (+5%)</small>
                        </div>
                        <div class="form-group">
                            <label>üî¥ Stop Loss Price ($)</label>
                            <input type="number" id="oco-stop-loss" step="0.01" value="${lossPrice}">
                            <small>Precio de p√©rdida m√°xima (-5%)</small>
                        </div>
                        <button class="execute-btn" id="createOCO">‚öñÔ∏è Crear OCO Order</button>
                        <button class="cancel-btn" onclick="document.getElementById('advancedOrderForm-spot').style.display='none'">‚ùå Cancelar</button>
                    </div>
                `;
            }

            createScaleInForm() {
                return `
                    <div class="advanced-form">
                        <h5>üìà Scale In Configuration</h5>
                        <div class="form-group">
                            <label>Inversi√≥n Total (USDT)</label>
                            <input type="number" id="scalein-total" step="1" value="500" max="${this.usdtBalance}">
                            <small>Disponible: ${this.usdtBalance.toFixed(2)} USDT</small>
                        </div>
                        <div class="form-group">
                            <label>N√∫mero de Entradas</label>
                            <select id="scalein-levels">
                                <option value="3">3 niveles</option>
                                <option value="4" selected>4 niveles</option>
                                <option value="5">5 niveles</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Reducci√≥n por Nivel (%)</label>
                            <input type="number" id="scalein-reduction" value="3" step="0.5" min="1" max="10">
                            <small>% de reducci√≥n en precio entre niveles</small>
                        </div>
                        <div id="scalein-preview" class="info-box"></div>
                        <button class="execute-btn" id="createScaleIn">üìà Crear Scale In</button>
                        <button class="preview-btn" id="previewScaleIn" style="background: #3498db;">üëÅÔ∏è Vista Previa</button>
                        <button class="cancel-btn" onclick="document.getElementById('advancedOrderForm-spot').style.display='none'">‚ùå Cancelar</button>
                    </div>
                `;
            }

            createScaleOutForm() {
                if (this.cryptoBalance === 0) {
                    return `
                        <div class="advanced-form">
                            <h5>üìâ Scale Out Configuration</h5>
                            <div class="info-box">
                                <strong>‚ö†Ô∏è No tienes ${this.symbol.replace('USDT', '')} para vender</strong><br>
                                Necesitas tener crypto antes de crear una orden Scale Out.
                            </div>
                            <button class="cancel-btn" onclick="document.getElementById('advancedOrderForm-spot').style.display='none'">‚ùå Cerrar</button>
                        </div>
                    `;
                }

                return `
                    <div class="advanced-form">
                        <h5>üìâ Scale Out Configuration</h5>
                        <div class="form-group">
                            <label>Cantidad Total a Vender</label>
                            <input type="number" id="scaleout-amount" step="0.001" value="${this.cryptoBalance}" max="${this.cryptoBalance}">
                            <small>Disponible: ${this.cryptoBalance.toFixed(6)} ${this.symbol.replace('USDT', '')}</small>
                        </div>
                        <div class="form-group">
                            <label>N√∫mero de Salidas</label>
                            <select id="scaleout-levels">
                                <option value="3">3 niveles</option>
                                <option value="4" selected>4 niveles</option>
                                <option value="5">5 niveles</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Incremento por Nivel (%)</label>
                            <input type="number" id="scaleout-increment" value="5" step="0.5" min="1" max="15">
                            <small>% de incremento en precio entre niveles</small>
                        </div>
                        <div id="scaleout-preview" class="info-box"></div>
                        <button class="execute-btn" id="createScaleOut">üìâ Crear Scale Out</button>
                        <button class="preview-btn" id="previewScaleOut" style="background: #3498db;">üëÅÔ∏è Vista Previa</button>
                        <button class="cancel-btn" onclick="document.getElementById('advancedOrderForm-spot').style.display='none'">‚ùå Cancelar</button>
                    </div>
                `;
            }

            setupAdvancedOrderListeners(orderType) {
                switch (orderType) {
                    case 'trailing-stop':
                        const createTrailingBtn = document.getElementById('createTrailingStop');
                        if (createTrailingBtn) {
                            createTrailingBtn.addEventListener('click', () => this.createTrailingStopOrder());
                        }
                        break;
                    case 'oco':
                        const createOCOBtn = document.getElementById('createOCO');
                        if (createOCOBtn) {
                            createOCOBtn.addEventListener('click', () => this.createOCOOrder());
                        }
                        break;
                    case 'scale-in':
                        const createScaleInBtn = document.getElementById('createScaleIn');
                        const previewScaleInBtn = document.getElementById('previewScaleIn');
                        if (createScaleInBtn) {
                            createScaleInBtn.addEventListener('click', () => this.createScaleInOrder());
                        }
                        if (previewScaleInBtn) {
                            previewScaleInBtn.addEventListener('click', () => this.previewScaleIn());
                        }
                        break;
                    case 'scale-out':
                        const createScaleOutBtn = document.getElementById('createScaleOut');
                        const previewScaleOutBtn = document.getElementById('previewScaleOut');
                        if (createScaleOutBtn) {
                            createScaleOutBtn.addEventListener('click', () => this.createScaleOutOrder());
                        }
                        if (previewScaleOutBtn) {
                            previewScaleOutBtn.addEventListener('click', () => this.previewScaleOut());
                        }
                        break;
                }
            }

            createTrailingStopOrder() {
                const amount = parseFloat(document.getElementById('trailing-amount').value);
                const distance = parseFloat(document.getElementById('trailing-distance').value);

                if (!amount || amount <= 0) {
                    this.showMessage('Ingresa una cantidad v√°lida', 'error');
                    return;
                }

                if (amount > this.cryptoBalance) {
                    this.showMessage('Cantidad insuficiente de crypto', 'error');
                    return;
                }

                const order = {
                    id: Date.now(),
                    type: 'trailing-stop',
                    amount: amount,
                    distance: distance,
                    triggerPrice: this.currentPrice,
                    currentStopPrice: this.currentPrice * (1 - distance / 100),
                    highestPrice: this.currentPrice,
                    status: 'active',
                    timestamp: new Date().toISOString()
                };

                if (!this.advancedOrders) this.advancedOrders = [];
                this.advancedOrders.push(order);

                this.showMessage(`üéØ Trailing Stop creado: ${amount} ${this.symbol.replace('USDT', '')} con trail de ${distance}%`, 'success');
                this.saveData();
                
                document.getElementById('advancedOrderForm-spot').style.display = 'none';
                document.querySelectorAll('#manual-spot .advanced-order-btn').forEach(btn => btn.classList.remove('active'));
            }

            createOCOOrder() {
                const amount = parseFloat(document.getElementById('oco-amount').value);
                const takeProfitPrice = parseFloat(document.getElementById('oco-take-profit').value);
                const stopLossPrice = parseFloat(document.getElementById('oco-stop-loss').value);

                if (!amount || amount <= 0) {
                    this.showMessage('Ingresa una cantidad v√°lida', 'error');
                    return;
                }

                if (amount > this.cryptoBalance) {
                    this.showMessage('Cantidad insuficiente de crypto', 'error');
                    return;
                }

                if (!takeProfitPrice || !stopLossPrice) {
                    this.showMessage('Ingresa precios v√°lidos para Take Profit y Stop Loss', 'error');
                    return;
                }

                if (takeProfitPrice <= this.currentPrice || stopLossPrice >= this.currentPrice) {
                    this.showMessage('Take Profit debe ser mayor al precio actual y Stop Loss menor', 'error');
                    return;
                }

                const order = {
                    id: Date.now(),
                    type: 'oco',
                    amount: amount,
                    takeProfitPrice: takeProfitPrice,
                    stopLossPrice: stopLossPrice,
                    status: 'active',
                    timestamp: new Date().toISOString()
                };

                if (!this.advancedOrders) this.advancedOrders = [];
                this.advancedOrders.push(order);

                this.showMessage(`‚öñÔ∏è OCO Order creada: TP $${takeProfitPrice.toLocaleString()} / SL $${stopLossPrice.toLocaleString()}`, 'success');
                this.saveData();
                
                document.getElementById('advancedOrderForm-spot').style.display = 'none';
                document.querySelectorAll('#manual-spot .advanced-order-btn').forEach(btn => btn.classList.remove('active'));
            }

            previewScaleIn() {
                const total = parseFloat(document.getElementById('scalein-total').value);
                const levels = parseInt(document.getElementById('scalein-levels').value);
                const reduction = parseFloat(document.getElementById('scalein-reduction').value);

                if (!total || !levels || !reduction) {
                    document.getElementById('scalein-preview').innerHTML = '<small>Complete los campos para ver vista previa</small>';
                    return;
                }

                const basePrice = this.currentPrice;
                const amountPerLevel = total / levels;
                let preview = '<strong>üìä Vista Previa Scale In:</strong><br><br>';

                for (let i = 0; i < levels; i++) {
                    const price = basePrice * Math.pow(1 - reduction / 100, i);
                    const crypto = amountPerLevel / price;
                    const status = price <= this.currentPrice ? '‚úÖ' : '‚è≥';
                    preview += `${status} Nivel ${i + 1}: $${amountPerLevel.toFixed(0)} a $${price.toLocaleString()} = ${crypto.toFixed(6)} ${this.symbol.replace('USDT', '')}<br>`;
                }

                document.getElementById('scalein-preview').innerHTML = preview;
            }

            createScaleInOrder() {
                const total = parseFloat(document.getElementById('scalein-total').value);
                const levels = parseInt(document.getElementById('scalein-levels').value);
                const reduction = parseFloat(document.getElementById('scalein-reduction').value);

                if (!total || !levels || !reduction) {
                    this.showMessage('Completa todos los campos', 'error');
                    return;
                }

                if (total > this.usdtBalance) {
                    this.showMessage('Fondos insuficientes', 'error');
                    return;
                }

                const basePrice = this.currentPrice;
                const order = {
                    id: Date.now(),
                    type: 'scale-in',
                    totalAmount: total,
                    levels: levels,
                    reduction: reduction,
                    basePrice: basePrice,
                    executedLevels: 0,
                    status: 'active',
                    timestamp: new Date().toISOString()
                };

                if (!this.advancedOrders) this.advancedOrders = [];
                this.advancedOrders.push(order);

                this.showMessage(`üìà Scale In creado: ${levels} niveles por $${total.toLocaleString()} total`, 'success');
                this.saveData();
                
                document.getElementById('advancedOrderForm-spot').style.display = 'none';
                document.querySelectorAll('#manual-spot .advanced-order-btn').forEach(btn => btn.classList.remove('active'));
            }

            previewScaleOut() {
                const amount = parseFloat(document.getElementById('scaleout-amount').value);
                const levels = parseInt(document.getElementById('scaleout-levels').value);
                const increment = parseFloat(document.getElementById('scaleout-increment').value);

                if (!amount || !levels || !increment) {
                    document.getElementById('scaleout-preview').innerHTML = '<small>Complete los campos para ver vista previa</small>';
                    return;
                }

                const basePrice = this.currentPrice;
                const amountPerLevel = amount / levels;
                let preview = '<strong>üìä Vista Previa Scale Out:</strong><br><br>';

                for (let i = 0; i < levels; i++) {
                    const price = basePrice * Math.pow(1 + increment / 100, i);
                    const value = amountPerLevel * price;
                    const status = price <= this.currentPrice ? '‚úÖ' : '‚è≥';
                    preview += `${status} Nivel ${i + 1}: ${amountPerLevel.toFixed(6)} ${this.symbol.replace('USDT', '')} a $${price.toLocaleString()} = $${value.toFixed(2)}<br>`;
                }

                document.getElementById('scaleout-preview').innerHTML = preview;
            }

            createScaleOutOrder() {
                const amount = parseFloat(document.getElementById('scaleout-amount').value);
                const levels = parseInt(document.getElementById('scaleout-levels').value);
                const increment = parseFloat(document.getElementById('scaleout-increment').value);

                if (!amount || !levels || !increment) {
                    this.showMessage('Completa todos los campos', 'error');
                    return;
                }

                if (amount > this.cryptoBalance) {
                    this.showMessage('Cantidad insuficiente de crypto', 'error');
                    return;
                }

                const basePrice = this.currentPrice;
                const order = {
                    id: Date.now(),
                    type: 'scale-out',
                    totalAmount: amount,
                    levels: levels,
                    increment: increment,
                    basePrice: basePrice,
                    executedLevels: 0,
                    status: 'active',
                    timestamp: new Date().toISOString()
                };

                if (!this.advancedOrders) this.advancedOrders = [];
                this.advancedOrders.push(order);

                this.showMessage(`üìâ Scale Out creado: ${levels} niveles para ${amount.toFixed(6)} ${this.symbol.replace('USDT', '')}`, 'success');
                this.saveData();
                
                document.getElementById('advancedOrderForm-spot').style.display = 'none';
                document.querySelectorAll('#manual-spot .advanced-order-btn').forEach(btn => btn.classList.remove('active'));
            }

            closeIndividualPosition(positionId) {
                const positionIndex = this.activePositions.findIndex(p => p.id === positionId);
                if (positionIndex === -1) {
                    this.showMessage('Posici√≥n no encontrada', 'error');
                    return;
                }
                
                const position = this.activePositions[positionIndex];
                const pnl = (this.currentPrice - position.entryPrice) * position.quantity - position.fee;
                
                // Return crypto to USDT at current market price
                this.cryptoBalance -= position.quantity;
                this.usdtBalance += (position.quantity * this.currentPrice);
                
                // Update total PnL
                this.totalPnl += pnl;
                
                // Remove position
                this.activePositions.splice(positionIndex, 1);
                
                // Record in history
                this.tradeHistory.push({
                    type: 'close',
                    symbol: position.symbol.replace('USDT', ''),
                    quantity: position.quantity,
                    entryPrice: position.entryPrice,
                    exitPrice: this.currentPrice,
                    pnl: pnl,
                    timestamp: new Date()
                });
                
                this.updateDisplay();
                this.saveData(); // Save after closing position
                
                const cryptoSymbol = position.symbol.replace('USDT', '');
                this.showMessage(
                    `Posici√≥n ${cryptoSymbol} cerrada: PnL ${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)} USDT`, 
                    pnl >= 0 ? 'success' : 'error'
                );
            }

            loadData() {
                const savedData = DataManager.loadData('manualSpotData');
                if (savedData) {
                    this.usdtBalance = savedData.usdtBalance || 1000.00;
                    this.cryptoBalance = savedData.cryptoBalance || 0;
                    this.totalValue = savedData.totalValue || 1000.00;
                    this.totalPnl = savedData.totalPnl || 0;
                    this.totalTrades = savedData.totalTrades || 0;
                    this.activePositions = savedData.activePositions || [];
                    this.tradeHistory = savedData.tradeHistory || [];
                    this.symbol = savedData.symbol || 'BTCUSDT';
                    
                    // Restore form values if saved
                    if (savedData.formData) {
                        setTimeout(() => {
                            const symbolSelect = document.getElementById('symbol-manual-spot');
                            if (symbolSelect) symbolSelect.value = this.symbol;
                        }, 100);
                    }
                }
            }

            saveData() {
                const dataToSave = {
                    usdtBalance: this.usdtBalance,
                    cryptoBalance: this.cryptoBalance,
                    totalValue: this.totalValue,
                    totalPnl: this.totalPnl,
                    totalTrades: this.totalTrades,
                    activePositions: this.activePositions,
                    tradeHistory: this.tradeHistory,
                    symbol: this.symbol,
                    formData: {
                        orderType: this.orderType,
                        orderMode: this.orderMode
                    },
                    lastSaved: new Date().toISOString()
                };
                
                DataManager.saveData('manualSpotData', dataToSave);
            }

            setupAutoSave() {
                // Save data every 10 seconds
                setInterval(() => {
                    this.saveData();
                }, 10000);
                
                // Save on page unload
                window.addEventListener('beforeunload', () => {
                    this.saveData();
                });
            }

            showMessage(message, type) {
                const messageArea = document.getElementById('messageArea-manual-spot');
                if (messageArea) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = type;
                    messageDiv.textContent = message;
                    
                    messageArea.innerHTML = '';
                    messageArea.appendChild(messageDiv);
                    
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 3000);
                }
            }
        }

        // Manual Futures Trading Class  
        class ManualFuturesTrader {
            constructor() {
                this.currentPrice = 0;
                this.availableMargin = 1000.00;
                this.usedMargin = 0;
                this.unrealizedPnl = 0;
                this.realizedPnl = 0;
                this.fundingFees = 0;
                this.totalTrades = 0;
                this.activePositions = [];
                this.tradeHistory = [];
                this.chart = null;
                this.priceHistory = [];
                this.orderType = 'long';
                this.orderMode = 'limit';
                this.leverage = 10;
                this.symbol = 'BTCUSDT';
                
                this.init();
            }

            init() {
                this.loadData(); // Load saved data first
                this.setupEventListeners();
                this.initializeChart();
                this.getCurrentPrice();
                this.updateDisplay();
                this.startFundingFeeTimer();
                this.startPriceUpdates();
                this.setupAutoSave(); // Setup auto-save
            }

            startPriceUpdates() {
                // Update price every 2 seconds
                setInterval(() => {
                    this.getCurrentPrice();
                    this.checkStopLossTakeProfit();
                }, 2000);
            }

            setupEventListeners() {
                // Leverage selector
                document.querySelectorAll('#manual-futures .leverage-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#manual-futures .leverage-btn').forEach(b => {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        this.leverage = parseInt(btn.dataset.leverage);
                        this.calculatePositionSize();
                    });
                });

                // Order type selector (Long/Short)
                document.querySelectorAll('#manual-futures .order-type-btn[data-type]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#manual-futures .order-type-btn[data-type]').forEach(b => {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        this.orderType = btn.dataset.type;
                    });
                });

                // Order mode selector (Market/Limit)
                document.querySelectorAll('#manual-futures .order-type-btn[data-order]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#manual-futures .order-type-btn[data-order]').forEach(b => {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        this.orderMode = btn.dataset.order;
                        this.updateOrderForm();
                    });
                });

                // Symbol change
                document.getElementById('symbol-manual-futures').addEventListener('change', () => {
                    this.symbol = document.getElementById('symbol-manual-futures').value;
                    this.getCurrentPrice();
                });

                // Price/Margin changes
                document.getElementById('orderPrice-manual-futures').addEventListener('input', () => {
                    this.calculatePositionSize();
                });
                
                document.getElementById('orderMargin-manual-futures').addEventListener('input', () => {
                    this.calculatePositionSize();
                });

                // Execute buttons
                document.getElementById('executeLong-manual-futures').addEventListener('click', () => {
                    this.executeTrade('long');
                });
                
                document.getElementById('executeShort-manual-futures').addEventListener('click', () => {
                    this.executeTrade('short');
                });

                // Balance editor button
                document.getElementById('editBalanceFutures').addEventListener('click', () => {
                    this.editBalance();
                });
            }

            async getCurrentPrice() {
                try {
                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${this.symbol}`);
                    const data = await response.json();
                    this.currentPrice = parseFloat(data.price);
                    
                    // Update connection status
                    this.updateConnectionStatus(true);
                    
                    // Update current price display
                    const priceDisplay = document.getElementById('currentPriceDisplay-manual-futures');
                    if (priceDisplay) {
                        priceDisplay.textContent = this.currentPrice.toLocaleString();
                    }
                    
                    // Update price in form
                    if (this.orderMode === 'market') {
                        document.getElementById('orderPrice-manual-futures').value = this.currentPrice;
                    }
                    
                    this.calculatePositionSize();
                    this.updatePositionValues();
                    this.updateDisplay(); // Update display when price changes
                    
                } catch (error) {
                    this.updateConnectionStatus(false);
                    this.showMessage('Error al obtener precio: ' + error.message, 'error');
                }
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    if (connected) {
                        statusElement.innerHTML = 'üü¢ Conectado';
                        statusElement.style.color = '#2ecc71';
                    } else {
                        statusElement.innerHTML = 'üî¥ Error de Conexi√≥n';
                        statusElement.style.color = '#e74c3c';
                    }
                }
            }

            calculatePositionSize() {
                const price = parseFloat(document.getElementById('orderPrice-manual-futures').value) || 0;
                const margin = parseFloat(document.getElementById('orderMargin-manual-futures').value) || 0;
                const positionSize = (margin * this.leverage) / price;
                
                document.getElementById('orderSize-manual-futures').value = positionSize.toFixed(3);
                
                // Update margin info
                const liquidationPrice = this.calculateLiquidationPrice(price, this.orderType);
                const marginInfo = document.getElementById('marginInfo-manual-futures');
                if (marginInfo) {
                    marginInfo.innerHTML = `
                        üíº Margen Inicial: $${margin} | Posici√≥n: $${(margin * this.leverage).toFixed(0)} | 
                        Liquidaci√≥n: ~$${liquidationPrice.toFixed(0)}
                    `;
                }
            }

            calculateLiquidationPrice(entryPrice, type) {
                const maintenanceMarginRate = 0.005; // 0.5%
                const fees = 0.001; // 0.1%
                
                if (type === 'long') {
                    return entryPrice * (1 - (1/this.leverage) + maintenanceMarginRate + fees);
                } else {
                    return entryPrice * (1 + (1/this.leverage) + maintenanceMarginRate + fees);
                }
            }

            updateOrderForm() {
                const priceInput = document.getElementById('orderPrice-manual-futures');
                if (this.orderMode === 'market') {
                    priceInput.value = this.currentPrice;
                    priceInput.disabled = true;
                } else {
                    priceInput.disabled = false;
                }
            }

            executeTrade(type) {
                const price = parseFloat(document.getElementById('orderPrice-manual-futures').value) || 0;
                const margin = parseFloat(document.getElementById('orderMargin-manual-futures').value) || 0;
                const size = parseFloat(document.getElementById('orderSize-manual-futures').value) || 0;
                const positionValue = margin * this.leverage;
                const fee = positionValue * 0.001; // 0.1% fee
                const stopLoss = parseFloat(document.getElementById('stopLoss-manual-futures').value) || 0;
                const takeProfit = parseFloat(document.getElementById('takeProfit-manual-futures').value) || 0;

                if (this.availableMargin < margin + fee) {
                    this.showMessage('Margen insuficiente para abrir la posici√≥n', 'error');
                    return;
                }
                
                // Execute futures order
                this.availableMargin -= (margin + fee);
                this.usedMargin += margin;
                
                // Create position with stop loss and take profit
                const position = {
                    id: Date.now(),
                    type: type,
                    symbol: this.symbol,
                    entryPrice: price,
                    size: size,
                    margin: margin,
                    leverage: this.leverage,
                    positionValue: positionValue,
                    fee: fee,
                    liquidationPrice: this.calculateLiquidationPrice(price, type),
                    stopLoss: stopLoss > 0 ? (type === 'long' ? price * (1 - stopLoss / 100) : price * (1 + stopLoss / 100)) : null,
                    takeProfit: takeProfit > 0 ? (type === 'long' ? price * (1 + takeProfit / 100) : price * (1 - takeProfit / 100)) : null,
                    timestamp: new Date()
                };
                
                this.activePositions.push(position);
                this.totalTrades++;
                
                const typeText = type === 'long' ? 'LONG' : 'SHORT';
                this.showMessage(`Posici√≥n ${typeText} abierta: ${size.toFixed(3)} ${this.symbol.replace('USDT', '')} a $${price}`, 'success');
                
                this.updateDisplay();
                this.checkStopLossTakeProfit();
                this.saveData(); // Save after opening position
            }

            closePosition(positionId, reason = 'manual') {
                const positionIndex = this.activePositions.findIndex(p => p.id === positionId);
                if (positionIndex === -1) return;
                
                const position = this.activePositions[positionIndex];
                const pnl = this.calculatePositionPnl(position, this.currentPrice);
                
                // Return margin and add/subtract PnL
                this.availableMargin += position.margin;
                this.usedMargin -= position.margin;
                this.realizedPnl += pnl;
                
                // Remove position
                this.activePositions.splice(positionIndex, 1);
                
                // Record in history
                this.tradeHistory.push({
                    type: 'close',
                    symbol: position.symbol.replace('USDT', ''),
                    positionType: position.type,
                    size: position.size,
                    entryPrice: position.entryPrice,
                    exitPrice: this.currentPrice,
                    pnl: pnl,
                    reason: reason,
                    timestamp: new Date()
                });
                
                const reasonText = reason === 'liquidation' ? 'Liquidada' : 
                                  reason === 'stop-loss' ? 'Stop Loss' :
                                  reason === 'take-profit' ? 'Take Profit' : 'Cerrada';
                
                this.showMessage(`Posici√≥n ${reasonText}: PnL ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`, 
                                pnl >= 0 ? 'success' : 'error');
                
                this.updateDisplay();
                this.saveData(); // Save after closing position
            }

            calculatePositionPnl(position, currentPrice) {
                if (position.type === 'long') {
                    return (currentPrice - position.entryPrice) * position.size - position.fee;
                } else {
                    return (position.entryPrice - currentPrice) * position.size - position.fee;
                }
            }

            checkStopLossTakeProfit() {
                // Use a copy of the array to avoid issues with concurrent modification
                const positionsToCheck = [...this.activePositions];
                
                positionsToCheck.forEach(position => {
                    // Check liquidation
                    if ((position.type === 'long' && this.currentPrice <= position.liquidationPrice) ||
                        (position.type === 'short' && this.currentPrice >= position.liquidationPrice)) {
                        this.closePosition(position.id, 'liquidation');
                        return;
                    }
                    
                    // Check stop loss
                    if (position.stopLoss) {
                        if ((position.type === 'long' && this.currentPrice <= position.stopLoss) ||
                            (position.type === 'short' && this.currentPrice >= position.stopLoss)) {
                            this.closePosition(position.id, 'stop-loss');
                            return;
                        }
                    }
                    
                    // Check take profit
                    if (position.takeProfit) {
                        if ((position.type === 'long' && this.currentPrice >= position.takeProfit) ||
                            (position.type === 'short' && this.currentPrice <= position.takeProfit)) {
                            this.closePosition(position.id, 'take-profit');
                            return;
                        }
                    }
                });
            }

            updatePositionValues() {
                this.unrealizedPnl = 0;
                this.activePositions.forEach(position => {
                    const pnl = this.calculatePositionPnl(position, this.currentPrice);
                    position.unrealizedPnl = pnl;
                    this.unrealizedPnl += pnl;
                });
            }

            startFundingFeeTimer() {
                // Simulate funding fees every 30 seconds (normally 8 hours)
                setInterval(() => {
                    if (this.activePositions.length > 0) {
                        // Random funding rate between -0.01% to +0.01%
                        const fundingRate = (Math.random() - 0.5) * 0.0002;
                        
                        this.activePositions.forEach(position => {
                            const fundingFee = position.positionValue * Math.abs(fundingRate);
                            this.fundingFees += fundingFee * (fundingRate > 0 ? -1 : 1);
                        });
                        
                        this.updateDisplay();
                    }
                }, 30000);
            }

            updateDisplay() {
                // Update balances
                document.getElementById('futuresMargin').textContent = `${this.availableMargin.toFixed(2)} USDT`;
                document.getElementById('availableMargin-manual-futures').textContent = `${this.availableMargin.toFixed(2)} USDT`;
                document.getElementById('usedMargin-manual-futures').textContent = `${this.usedMargin.toFixed(2)} USDT`;
                
                // Update PnL
                document.getElementById('unrealizedPnl-manual-futures').textContent = 
                    `${this.unrealizedPnl >= 0 ? '+' : ''}${this.unrealizedPnl.toFixed(2)} USDT`;
                document.getElementById('realizedPnl-manual-futures').textContent = 
                    `${this.realizedPnl >= 0 ? '+' : ''}${this.realizedPnl.toFixed(2)} USDT`;
                document.getElementById('fundingFees-manual-futures').textContent = 
                    `${this.fundingFees >= 0 ? '+' : ''}${this.fundingFees.toFixed(2)} USDT`;
                    
                document.getElementById('totalTrades-manual-futures').textContent = this.totalTrades;
                
                // Update active positions display
                this.updateActivePositions();
            }

            updateActivePositions() {
                const container = document.getElementById('activePositions-manual-futures');
                
                if (this.activePositions.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #bdc3c7; padding: 20px;">No hay posiciones activas</div>';
                    return;
                }
                
                container.innerHTML = this.activePositions.map(position => {
                    const pnl = this.calculatePositionPnl(position, this.currentPrice);
                    const pnlPercent = (pnl / position.margin) * 100;
                    const pnlClass = pnl >= 0 ? 'pnl-positive' : 'pnl-negative';
                    
                    // Check if close to liquidation
                    const liquidationDistance = Math.abs(this.currentPrice - position.liquidationPrice) / this.currentPrice;
                    const liquidationRisk = liquidationDistance < 0.1 ? 'liquidation-risk' : '';
                    
                    return `
                        <div class="position-item ${liquidationRisk}">
                            <div>
                                <strong>${position.type.toUpperCase()} ${position.symbol.replace('USDT', '')}</strong><br>
                                ${position.size.toFixed(3)} @ $${position.entryPrice.toFixed(2)} | ${position.leverage}x<br>
                                <small>Liq: $${position.liquidationPrice.toFixed(0)}</small>
                            </div>
                            <div class="${pnlClass}">
                                ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}<br>
                                (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)
                                <br><button onclick="window.manualFuturesTrader.closePosition(${position.id})" 
                                          style="font-size: 10px; padding: 2px 6px; margin-top: 4px; background: #e74c3c; border: none; border-radius: 3px; color: white; cursor: pointer;">
                                    Cerrar
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            initializeChart() {
                const ctx = document.getElementById('futuresChart-manual');
                if (!ctx) return;
                
                this.chart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Precio',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1
                        }, {
                            label: 'PnL Unrealized',
                            data: [],
                            borderColor: '#2ecc71',
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#ecf0f1' }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                ticks: { color: '#bdc3c7' },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                ticks: { color: '#2ecc71' },
                                grid: { drawOnChartArea: false }
                            }
                        }
                    }
                });

                // Update chart periodically
                setInterval(() => {
                    this.updateChart();
                }, 5000);
            }

            updateChart() {
                if (!this.chart) return;

                this.priceHistory.push({
                    time: new Date(),
                    price: this.currentPrice,
                    pnl: this.unrealizedPnl
                });

                // Keep only last 20 points
                if (this.priceHistory.length > 20) {
                    this.priceHistory.shift();
                }

                const labels = this.priceHistory.map(item => 
                    item.time.toLocaleTimeString('es-ES', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    })
                );
                
                const priceData = this.priceHistory.map(item => item.price);
                const pnlData = this.priceHistory.map(item => item.pnl);

                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = priceData;
                this.chart.data.datasets[1].data = pnlData;
                this.chart.update('none');
            }

            editBalance() {
                const totalBalance = this.availableMargin + this.usedMargin;
                const newBalance = prompt(`Ingresa el nuevo balance total (USDT):\n\nBalance actual: ${totalBalance.toFixed(2)} USDT\nDisponible: ${this.availableMargin.toFixed(2)} USDT\nUsado: ${this.usedMargin.toFixed(2)} USDT`, totalBalance.toFixed(2));
                
                if (newBalance !== null && !isNaN(newBalance) && parseFloat(newBalance) > 0) {
                    const balanceValue = parseFloat(newBalance);
                    
                    if (balanceValue < this.usedMargin) {
                        this.showMessage(`El nuevo balance no puede ser menor al margen usado (${this.usedMargin.toFixed(2)} USDT)`, 'error');
                        return;
                    }
                    
                    // Update balances
                    this.availableMargin = balanceValue - this.usedMargin;
                    
                    this.updateDisplay();
                    this.saveData(); // Save after balance edit
                    this.showMessage(`Balance actualizado a ${balanceValue.toFixed(2)} USDT`, 'success');
                } else if (newBalance !== null) {
                    this.showMessage('Por favor ingresa un valor v√°lido mayor a 0', 'error');
                }
            }

            loadData() {
                const savedData = DataManager.loadData('manualFuturesData');
                if (savedData) {
                    this.availableMargin = savedData.availableMargin || 1000.00;
                    this.usedMargin = savedData.usedMargin || 0;
                    this.unrealizedPnl = savedData.unrealizedPnl || 0;
                    this.realizedPnl = savedData.realizedPnl || 0;
                    this.fundingFees = savedData.fundingFees || 0;
                    this.totalTrades = savedData.totalTrades || 0;
                    this.activePositions = savedData.activePositions || [];
                    this.tradeHistory = savedData.tradeHistory || [];
                    this.leverage = savedData.leverage || 10;
                    this.symbol = savedData.symbol || 'BTCUSDT';
                    
                    // Restore form values if saved
                    if (savedData.formData) {
                        setTimeout(() => {
                            const symbolSelect = document.getElementById('symbol-manual-futures');
                            if (symbolSelect) symbolSelect.value = this.symbol;
                            
                            // Restore leverage selection
                            document.querySelectorAll('#manual-futures .leverage-btn').forEach(btn => {
                                btn.classList.remove('active');
                                if (parseInt(btn.dataset.leverage) === this.leverage) {
                                    btn.classList.add('active');
                                }
                            });
                        }, 100);
                    }
                }
            }

            saveData() {
                const dataToSave = {
                    availableMargin: this.availableMargin,
                    usedMargin: this.usedMargin,
                    unrealizedPnl: this.unrealizedPnl,
                    realizedPnl: this.realizedPnl,
                    fundingFees: this.fundingFees,
                    totalTrades: this.totalTrades,
                    activePositions: this.activePositions,
                    tradeHistory: this.tradeHistory,
                    leverage: this.leverage,
                    symbol: this.symbol,
                    formData: {
                        orderType: this.orderType,
                        orderMode: this.orderMode
                    },
                    lastSaved: new Date().toISOString()
                };
                
                DataManager.saveData('manualFuturesData', dataToSave);
            }

            setupAutoSave() {
                // Save data every 10 seconds
                setInterval(() => {
                    this.saveData();
                }, 10000);
                
                // Save on page unload
                window.addEventListener('beforeunload', () => {
                    this.saveData();
                });
            }

            showMessage(message, type) {
                const messageArea = document.getElementById('messageArea-manual-futures');
                if (messageArea) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = type;
                    messageDiv.textContent = message;
                    
                    messageArea.innerHTML = '';
                    messageArea.appendChild(messageDiv);
                    
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 3000);
                }
            }
        }

        // Technical Indicators Calculator
        class TechnicalIndicators {
            static calculateRSI(prices, period = 14) {
                if (prices.length < period + 1) return 50;
                
                let gains = [];
                let losses = [];
                
                for (let i = 1; i < prices.length; i++) {
                    const change = prices[i] - prices[i - 1];
                    gains.push(change > 0 ? change : 0);
                    losses.push(change < 0 ? Math.abs(change) : 0);
                }
                
                const avgGain = gains.slice(-period).reduce((a, b) => a + b) / period;
                const avgLoss = losses.slice(-period).reduce((a, b) => a + b) / period;
                
                if (avgLoss === 0) return 100;
                
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            static calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                if (prices.length < slowPeriod) return { macd: 0, signal: 0, histogram: 0 };
                
                const fastEMA = this.calculateEMA(prices, fastPeriod);
                const slowEMA = this.calculateEMA(prices, slowPeriod);
                const macd = fastEMA - slowEMA;
                
                // Simplified signal calculation
                const signal = macd * 0.9; // Simplified for demo
                const histogram = macd - signal;
                
                return { macd, signal, histogram };
            }

            static calculateEMA(prices, period) {
                if (prices.length === 0) return 0;
                
                const multiplier = 2 / (period + 1);
                let ema = prices[0];
                
                for (let i = 1; i < prices.length; i++) {
                    ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
                }
                
                return ema;
            }

            static calculateBollingerBands(prices, period = 20, stdDev = 2) {
                if (prices.length < period) return { upper: 0, middle: 0, lower: 0 };
                
                const recentPrices = prices.slice(-period);
                const sma = recentPrices.reduce((a, b) => a + b) / period;
                
                const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
                const standardDeviation = Math.sqrt(variance);
                
                return {
                    upper: sma + (standardDeviation * stdDev),
                    middle: sma,
                    lower: sma - (standardDeviation * stdDev)
                };
            }

            static updateIndicators(symbol, currentPrice, priceHistory) {
                const prices = priceHistory.map(item => item.price);
                
                // RSI
                const rsi = this.calculateRSI(prices);
                const rsiElement = document.getElementById(`rsi-${symbol}`);
                if (rsiElement) {
                    rsiElement.textContent = rsi.toFixed(1);
                    rsiElement.className = `indicator-value ${rsi > 70 ? 'indicator-bearish' : rsi < 30 ? 'indicator-bullish' : 'indicator-neutral'}`;
                }

                // MACD
                const macd = this.calculateMACD(prices);
                const macdElement = document.getElementById(`macd-${symbol}`);
                if (macdElement) {
                    macdElement.textContent = macd.macd.toFixed(2);
                    macdElement.className = `indicator-value ${macd.macd > 0 ? 'indicator-bullish' : 'indicator-bearish'}`;
                }

                // Bollinger Bands
                const bb = this.calculateBollingerBands(prices);
                const bbElement = document.getElementById(`bb-${symbol}`);
                if (bbElement) {
                    const position = currentPrice > bb.upper ? 'Overbought' : currentPrice < bb.lower ? 'Oversold' : 'Normal';
                    bbElement.textContent = position;
                    bbElement.className = `indicator-value ${position === 'Oversold' ? 'indicator-bullish' : position === 'Overbought' ? 'indicator-bearish' : 'indicator-neutral'}`;
                }

                // EMA 20
                const ema20 = this.calculateEMA(prices, 20);
                const ema20Element = document.getElementById(`ema20-${symbol}`);
                if (ema20Element) {
                    ema20Element.textContent = ema20.toFixed(2);
                    ema20Element.className = `indicator-value ${currentPrice > ema20 ? 'indicator-bullish' : 'indicator-bearish'}`;
                }

                // Volume (simulated)
                const volumeElement = document.getElementById(`volume-${symbol}`);
                if (volumeElement) {
                    const trend = Math.random() > 0.5 ? 'High' : 'Normal';
                    volumeElement.textContent = trend;
                    volumeElement.className = `indicator-value ${trend === 'High' ? 'indicator-bullish' : 'indicator-neutral'}`;
                }
            }
        }

        // DCA Bot Class
        class DCABot {
            constructor() {
                this.isRunning = false;
                this.symbol = 'BTCUSDT';
                this.amount = 50;
                this.frequency = 'daily';
                this.target = 1000;
                this.totalInvested = 0;
                this.totalQuantity = 0;
                this.averagePrice = 0;
                this.executions = [];
                this.nextExecution = null;
                this.currentPrice = 0;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.setDefaultDates();
                this.loadData();
                this.getCurrentPrice();
                this.updateDisplay();
            }

            setDefaultDates() {
                const today = new Date();
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                const startDateElement = document.getElementById('dca-start-date');
                const endDateElement = document.getElementById('backtest-end');
                
                if (startDateElement) {
                    startDateElement.value = tomorrow.toISOString().split('T')[0];
                }
                if (endDateElement) {
                    endDateElement.value = today.toISOString().split('T')[0];
                }
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startDCA');
                const stopBtn = document.getElementById('stopDCA');
                const symbolSelect = document.getElementById('dca-symbol');
                
                if (startBtn) startBtn.addEventListener('click', () => this.startDCA());
                if (stopBtn) stopBtn.addEventListener('click', () => this.stopDCA());
                if (symbolSelect) {
                    symbolSelect.addEventListener('change', (e) => {
                        this.symbol = e.target.value;
                        this.getCurrentPrice();
                    });
                }
            }

            async getCurrentPrice() {
                try {
                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${this.symbol}`);
                    const data = await response.json();
                    this.currentPrice = parseFloat(data.price);
                } catch (error) {
                    console.error('Error fetching price:', error);
                }
            }

            startDCA() {
                this.amount = parseFloat(document.getElementById('dca-amount').value);
                this.frequency = document.getElementById('dca-frequency').value;
                this.target = parseFloat(document.getElementById('dca-target').value);
                
                this.isRunning = true;
                this.scheduleNextExecution();
                this.updateDisplay();
                this.showMessage('DCA Bot iniciado correctamente', 'success');
            }

            stopDCA() {
                this.isRunning = false;
                if (this.dcaInterval) {
                    clearInterval(this.dcaInterval);
                }
                this.updateDisplay();
                this.showMessage('DCA Bot detenido', 'error');
            }

            scheduleNextExecution() {
                // Intervalos cortos para demostraci√≥n
                const frequencies = {
                    'daily': 30 * 1000,    // 30 segundos para demo
                    'weekly': 60 * 1000,   // 1 minuto para demo
                    'monthly': 120 * 1000,  // 2 minutos para demo
                    'custom': 15 * 1000    // 15 segundos para demo
                };

                const interval = frequencies[this.frequency] || frequencies['daily'];
                
                this.dcaInterval = setInterval(() => {
                    if (this.totalInvested < this.target) {
                        this.executeDCA();
                    } else {
                        this.stopDCA();
                        this.showMessage('Meta DCA alcanzada!', 'success');
                    }
                }, interval);

                this.nextExecution = new Date(Date.now() + interval);
            }

            async executeDCA() {
                await this.getCurrentPrice();
                
                const quantity = this.amount / this.currentPrice;
                this.totalInvested += this.amount;
                this.totalQuantity += quantity;
                this.averagePrice = this.totalInvested / this.totalQuantity;

                this.executions.push({
                    date: new Date(),
                    price: this.currentPrice,
                    amount: this.amount,
                    quantity: quantity
                });

                this.updateDisplay();
                this.saveData();
                this.showMessage(`DCA ejecutado: ${quantity.toFixed(6)} ${this.symbol.replace('USDT', '')} @ $${this.currentPrice}`, 'success');
            }

            updateDisplay() {
                // Safely update text content
                const elements = {
                    'dca-status': this.isRunning ? 'Activo' : 'Inactivo',
                    'dca-progress': `$${this.totalInvested} / $${this.target} (${((this.totalInvested/this.target)*100).toFixed(1)}%)`,
                    'dca-next-execution': this.nextExecution ? this.nextExecution.toLocaleString() : '--',
                    'dca-avg-price': this.averagePrice > 0 ? `$${this.averagePrice.toFixed(2)}` : '--',
                    'dca-total-invested': `$${this.totalInvested.toFixed(2)}`,
                    'dca-total-quantity': `${this.totalQuantity.toFixed(6)} ${this.symbol.replace('USDT', '')}`
                };

                Object.entries(elements).forEach(([id, text]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = text;
                });

                // Update button states
                const startBtn = document.getElementById('startDCA');
                const stopBtn = document.getElementById('stopDCA');
                
                if (startBtn && stopBtn) {
                    startBtn.disabled = this.isRunning;
                    stopBtn.disabled = !this.isRunning;
                    
                    const startIndicator = startBtn.querySelector('.status-indicator');
                    const stopIndicator = stopBtn.querySelector('.status-indicator');
                    
                    if (startIndicator) {
                        startIndicator.className = `status-indicator ${this.isRunning ? 'status-active' : 'status-inactive'}`;
                    }
                    if (stopIndicator) {
                        stopIndicator.className = `status-indicator ${this.isRunning ? 'status-inactive' : 'status-inactive'}`;
                    }
                }

                this.updateExecutionsList();
            }

            updateExecutionsList() {
                const container = document.getElementById('dca-executions');
                
                if (this.executions.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #bdc3c7; padding: 20px;">No hay ejecuciones a√∫n</div>';
                    return;
                }

                container.innerHTML = this.executions.slice(-10).reverse().map(exec => `
                    <div class="dca-execution dca-completed">
                        <div>
                            <strong>${exec.date.toLocaleDateString()}</strong><br>
                            ${exec.quantity.toFixed(6)} @ $${exec.price.toFixed(2)}
                        </div>
                        <div>$${exec.amount.toFixed(2)}</div>
                    </div>
                `).join('');
            }

            loadData() {
                const data = DataManager.loadData('dcaBotData');
                if (data) {
                    this.totalInvested = data.totalInvested || 0;
                    this.totalQuantity = data.totalQuantity || 0;
                    this.averagePrice = data.averagePrice || 0;
                    this.executions = data.executions || [];
                }
            }

            saveData() {
                DataManager.saveData('dcaBotData', {
                    totalInvested: this.totalInvested,
                    totalQuantity: this.totalQuantity,
                    averagePrice: this.averagePrice,
                    executions: this.executions
                });
            }

            showMessage(message, type) {
                const messageArea = document.getElementById('messageArea-dca');
                if (messageArea) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = type;
                    messageDiv.textContent = message;
                    
                    messageArea.innerHTML = '';
                    messageArea.appendChild(messageDiv);
                    
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 3000);
                }
            }
        }

        // Portfolio Manager Class
        class PortfolioManager {
            constructor() {
                // Initialize with zeros - will load from storage if available
                this.totalValue = 0;
                this.dailyPnl = 0;
                this.totalTrades = 0;
                this.winRate = 0;
                this.sharpeRatio = 0;
                this.maxDrawdown = 0;
                
                this.init();
            }

            init() {
                this.loadData(); // Load saved data first
                this.updateMetrics();
                this.initializeChart();
                // Update every 30 seconds
                setInterval(() => this.updateMetrics(), 30000);
            }

            loadData() {
                const savedData = DataManager.loadData('portfolioData');
                if (savedData && Object.keys(savedData).length > 0) {
                    // Only load if there's actual data (not empty object from reset)
                    this.totalValue = savedData.totalValue || 0;
                    this.dailyPnl = savedData.dailyPnl || 0;
                    this.totalTrades = savedData.totalTrades || 0;
                    this.winRate = savedData.winRate || 0;
                    this.sharpeRatio = savedData.sharpeRatio || 0;
                    this.maxDrawdown = savedData.maxDrawdown || 0;
                    console.log('Portfolio data loaded from storage');
                } else {
                    console.log('No portfolio data found, starting with zeros');
                }
            }

            saveData() {
                const dataToSave = {
                    totalValue: this.totalValue,
                    dailyPnl: this.dailyPnl,
                    totalTrades: this.totalTrades,
                    winRate: this.winRate,
                    sharpeRatio: this.sharpeRatio,
                    maxDrawdown: this.maxDrawdown,
                    lastSaved: new Date().toISOString()
                };
                DataManager.saveData('portfolioData', dataToSave);
            }

            updateMetrics() {
                // Only simulate changes if we have a non-zero portfolio
                if (this.totalValue > 0 || this.dailyPnl !== 0) {
                    this.totalValue += (Math.random() - 0.5) * 10;
                    this.dailyPnl += (Math.random() - 0.5) * 2;
                    
                    // Save data after updates
                    this.saveData();
                }
                
                // Update display elements
                const totalValueEl = document.getElementById('portfolio-total-value');
                const dailyPnlEl = document.getElementById('portfolio-daily-pnl');
                const totalTradesEl = document.getElementById('portfolio-total-trades');
                const winRateEl = document.getElementById('portfolio-win-rate');
                const sharpeEl = document.getElementById('portfolio-sharpe');
                const drawdownEl = document.getElementById('portfolio-drawdown');
                
                if (totalValueEl) totalValueEl.textContent = `$${this.totalValue.toFixed(2)}`;
                if (dailyPnlEl) dailyPnlEl.textContent = `${this.dailyPnl >= 0 ? '+' : ''}$${this.dailyPnl.toFixed(2)}`;
                if (totalTradesEl) totalTradesEl.textContent = this.totalTrades;
                if (winRateEl) winRateEl.textContent = `${this.winRate.toFixed(1)}%`;
                if (sharpeEl) sharpeEl.textContent = this.sharpeRatio.toFixed(2);
                if (drawdownEl) drawdownEl.textContent = `${this.maxDrawdown.toFixed(1)}%`;
            }

            setupEventListeners() {
                // Refresh button
                const refreshBtn = document.getElementById('refreshPortfolio');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => {
                        this.updateMetrics();
                        this.showMessage('Portfolio actualizado', 'success');
                    });
                }

                // Reset button - NEW!
                const resetBtn = document.getElementById('resetPortfolio');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetPortfolio());
                }

                // Export button
                const exportBtn = document.getElementById('exportPortfolio');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => this.exportData());
                }

                // Chart type buttons - FIXED!
                const chartBtns = document.querySelectorAll('#portfolio .chart-btn');
                console.log('Portfolio chart buttons found:', chartBtns.length);
                chartBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        console.log('Chart button clicked:', e.target.dataset.chart);
                        
                        // Remove active class from all buttons
                        chartBtns.forEach(b => b.classList.remove('active'));
                        
                        // Add active class to clicked button
                        e.target.classList.add('active');
                        
                        // Update chart and show message
                        const chartType = e.target.dataset.chart;
                        this.updateChart(chartType);
                        this.showMessage(`Gr√°fico cambiado a: ${chartType}`, 'info');
                    });
                    console.log('Listener added for chart type:', btn.dataset.chart);
                });
            }

            resetPortfolio() {
                if (confirm('üóëÔ∏è ¬øEst√°s seguro de que quieres reiniciar el portfolio?\n\nEsto pondr√° todos los valores en cero.\n\n‚ö†Ô∏è Esta acci√≥n no se puede deshacer.')) {
                    console.log('Resetting portfolio...');
                    
                    // Reset all values to zero
                    this.totalValue = 0;
                    this.dailyPnl = 0;
                    this.totalTrades = 0;
                    this.winRate = 0;
                    this.sharpeRatio = 0;
                    this.maxDrawdown = 0;

                    // Save the reset state immediately
                    this.saveData();
                    
                    // Also clear with empty object as backup
                    localStorage.removeItem('portfolioData');
                    
                    // Force update display
                    this.updateMetrics();
                    
                    // Reinitialize chart with zero data
                    if (this.chart) {
                        this.chart.destroy();
                    }
                    this.updateChart('value');
                    
                    this.showMessage('Portfolio reiniciado exitosamente - Todos los datos en cero', 'success');
                    console.log('Portfolio reset completed - all values set to zero');
                    console.log('Current values:', {
                        totalValue: this.totalValue,
                        dailyPnl: this.dailyPnl,
                        totalTrades: this.totalTrades,
                        winRate: this.winRate
                    });
                }
            }

            updateChart(chartType = 'value') {
                const canvas = document.getElementById('portfolioChart');
                if (!canvas) {
                    console.error('Portfolio chart canvas not found');
                    return;
                }

                const ctx = canvas.getContext('2d');
                
                // Clear existing chart
                if (this.chart) {
                    this.chart.destroy();
                }

                console.log('Creating chart for type:', chartType);

                let chartConfig;

                switch (chartType) {
                    case 'value':
                        chartConfig = {
                            type: 'line',
                            data: {
                                labels: ['Inicio', 'Ahora'],
                                datasets: [{
                                    label: 'Valor del Portfolio ($)',
                                    data: [2000, this.totalValue],
                                    borderColor: '#3498db',
                                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                                    borderWidth: 3,
                                    fill: true,
                                    tension: 0.4
                                }]
                            }
                        };
                        break;
                    case 'pnl':
                        chartConfig = {
                            type: 'line',
                            data: {
                                labels: ['Inicio', 'Ahora'],
                                datasets: [{
                                    label: 'PnL ($)',
                                    data: [0, this.dailyPnl],
                                    borderColor: this.dailyPnl >= 0 ? '#2ecc71' : '#e74c3c',
                                    backgroundColor: this.dailyPnl >= 0 ? 'rgba(46, 204, 113, 0.1)' : 'rgba(231, 76, 60, 0.1)',
                                    borderWidth: 3,
                                    fill: true,
                                    tension: 0.4
                                }]
                            }
                        };
                        break;
                    case 'allocation':
                        chartConfig = {
                            type: 'doughnut',
                            data: {
                                labels: ['BTC', 'ETH', 'USDT', 'Otros'],
                                datasets: [{
                                    data: [40, 30, 20, 10],
                                    backgroundColor: [
                                        '#f39c12',
                                        '#3498db', 
                                        '#2ecc71',
                                        '#9b59b6'
                                    ],
                                    borderWidth: 2,
                                    borderColor: 'rgba(255, 255, 255, 0.2)'
                                }]
                            }
                        };
                        break;
                    default:
                        chartType = 'value';
                        chartConfig = {
                            type: 'line',
                            data: {
                                labels: ['Inicio', 'Ahora'],
                                datasets: [{
                                    label: 'Valor del Portfolio ($)',
                                    data: [2000, this.totalValue],
                                    borderColor: '#3498db',
                                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                                    borderWidth: 3,
                                    fill: true,
                                    tension: 0.4
                                }]
                            }
                        };
                }

                // Common chart options
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            labels: { color: '#ecf0f1' }
                        }
                    }
                };

                if (chartType !== 'allocation') {
                    commonOptions.scales = {
                        x: {
                            ticks: { color: '#bdc3c7' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            ticks: { color: '#bdc3c7' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    };
                }

                chartConfig.options = commonOptions;

                try {
                    this.chart = new Chart(ctx, chartConfig);
                    console.log(`Chart created successfully for type: ${chartType}`);
                } catch (error) {
                    console.error('Error creating chart:', error);
                }
            }

            exportData() {
                const exportData = {
                    totalValue: this.totalValue,
                    dailyPnl: this.dailyPnl,
                    totalTrades: this.totalTrades,
                    winRate: this.winRate,
                    sharpeRatio: this.sharpeRatio,
                    maxDrawdown: this.maxDrawdown,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `portfolio-export-${new Date().getTime()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showMessage('Portfolio exportado exitosamente', 'success');
            }

            showMessage(message, type = 'info') {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 9999;
                    padding: 12px 20px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 600;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    ${type === 'success' ? 'background: linear-gradient(45deg, #27ae60, #2ecc71);' : 
                      type === 'error' ? 'background: linear-gradient(45deg, #e74c3c, #c0392b);' : 
                      'background: linear-gradient(45deg, #3498db, #2980b9);'}
                `;
                messageDiv.textContent = message;
                
                document.body.appendChild(messageDiv);
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, 3000);
            }

            initializeChart() {
                this.setupEventListeners();
                this.updateChart('value');
            }
        }

        // Alerts System Class
        class AlertsSystem {
            constructor() {
                this.alerts = [];
                this.activeCount = 2;
                this.triggeredToday = 5;
                this.totalCount = 24;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.loadData();
                this.updateDisplay();
                this.startPriceMonitoring();
            }

            setupEventListeners() {
                const createBtn = document.getElementById('createAlert');
                const testBtn = document.getElementById('testAlert');
                
                if (createBtn) createBtn.addEventListener('click', () => this.createAlert());
                if (testBtn) testBtn.addEventListener('click', () => this.testAlert());
            }

            createAlert() {
                const symbolElement = document.getElementById('alert-symbol');
                const conditionElement = document.getElementById('alert-condition');
                const valueElement = document.getElementById('alert-value');
                const messageElement = document.getElementById('alert-message');
                
                if (!symbolElement || !conditionElement || !valueElement) {
                    console.error('Alert form elements not found');
                    return;
                }
                
                const symbol = symbolElement.value;
                const condition = conditionElement.value;
                const value = parseFloat(valueElement.value);
                const message = messageElement ? messageElement.value : '';

                if (!value || value <= 0) {
                    this.showMessage('Por favor ingresa un valor v√°lido', 'error');
                    return;
                }

                const alert = {
                    id: Date.now(),
                    symbol: symbol,
                    condition: condition,
                    value: value,
                    message: message,
                    created: new Date(),
                    triggered: false
                };

                this.alerts.push(alert);
                this.activeCount++;
                this.totalCount++;
                
                this.updateDisplay();
                this.saveData();
                this.showMessage('Alerta creada correctamente', 'success');
            }

            testAlert() {
                this.playAlertSound();
                if (Notification.permission === 'granted') {
                    new Notification('Test Alert', {
                        body: 'Esta es una alerta de prueba',
                        icon: '/favicon.ico'
                    });
                }
                this.showMessage('Alerta de prueba ejecutada', 'success');
            }

            playAlertSound() {
                // Simple beep sound
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1);
            }

            startPriceMonitoring() {
                setInterval(() => {
                    this.checkAlerts();
                }, 5000);
            }

            async checkAlerts() {
                for (const alert of this.alerts) {
                    if (alert.triggered) continue;

                    try {
                        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${alert.symbol}`);
                        const data = await response.json();
                        const currentPrice = parseFloat(data.price);

                        let shouldTrigger = false;

                        switch (alert.condition) {
                            case 'above':
                                shouldTrigger = currentPrice > alert.value;
                                break;
                            case 'below':
                                shouldTrigger = currentPrice < alert.value;
                                break;
                        }

                        if (shouldTrigger) {
                            this.triggerAlert(alert, currentPrice);
                        }
                    } catch (error) {
                        console.error('Error checking alert:', error);
                    }
                }
            }

            triggerAlert(alert, currentPrice) {
                alert.triggered = true;
                alert.triggeredAt = new Date();
                alert.triggeredPrice = currentPrice;

                this.triggeredToday++;
                this.activeCount--;

                this.playAlertSound();

                if (Notification.permission === 'granted') {
                    new Notification(`Alert: ${alert.symbol}`, {
                        body: alert.message || `Price ${alert.condition} ${alert.value}`,
                        icon: '/favicon.ico'
                    });
                }

                this.updateDisplay();
                this.saveData();
            }

            removeAlert(alertId) {
                const index = this.alerts.findIndex(alert => alert.id === alertId);
                if (index > -1) {
                    this.alerts.splice(index, 1);
                    this.activeCount--;
                    this.updateDisplay();
                    this.saveData();
                    this.showMessage('Alerta eliminada', 'success');
                }
            }

            updateDisplay() {
                const activeCountElement = document.getElementById('alerts-active-count');
                const triggeredTodayElement = document.getElementById('alerts-triggered-today');
                const totalCountElement = document.getElementById('alerts-total-count');
                
                if (activeCountElement) activeCountElement.textContent = this.activeCount;
                if (triggeredTodayElement) triggeredTodayElement.textContent = this.triggeredToday;
                if (totalCountElement) totalCountElement.textContent = this.totalCount;
                
                this.updateActiveAlertsList();
            }

            updateActiveAlertsList() {
                const container = document.getElementById('activeAlerts');
                if (!container) return;
                
                if (this.alerts.length === 0) {
                    container.innerHTML = `
                        <div class="alert-item">
                            <div style="text-align: center; color: #bdc3c7; padding: 20px;">
                                No hay alertas activas. Crea una nueva alerta usando el formulario.
                            </div>
                        </div>
                    `;
                    return;
                }
                
                container.innerHTML = this.alerts.map(alert => `
                    <div class="alert-item ${alert.triggered ? 'alert-triggered' : 'alert-active'}">
                        <div>
                            <strong>${alert.symbol}</strong><br>
                            ${alert.condition} ${alert.value}
                            ${alert.message ? '<br><small>' + alert.message + '</small>' : ''}
                        </div>
                        <div>
                            <span style="color: ${alert.triggered ? '#e74c3c' : '#2ecc71'};">
                                ${alert.triggered ? 'Disparada' : 'Activa'}
                            </span>
                            <button onclick="removeAlert(${alert.id})" 
                                    style="margin-left: 10px; padding: 2px 6px; background: #e74c3c; border: none; border-radius: 3px; color: white; cursor: pointer;">
                                √ó
                            </button>
                        </div>
                    </div>
                `).join('');
            }

            loadData() {
                const data = DataManager.loadData('alertsData');
                if (data) {
                    this.alerts = data.alerts || [];
                    this.activeCount = data.activeCount || 2;
                    this.triggeredToday = data.triggeredToday || 5;
                    this.totalCount = data.totalCount || 24;
                }
            }

            saveData() {
                DataManager.saveData('alertsData', {
                    alerts: this.alerts,
                    activeCount: this.activeCount,
                    triggeredToday: this.triggeredToday,
                    totalCount: this.totalCount
                });
            }

            showMessage(message, type) {
                const messageArea = document.getElementById('messageArea-alerts');
                if (messageArea) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = type;
                    messageDiv.textContent = message;
                    
                    messageArea.innerHTML = '';
                    messageArea.appendChild(messageDiv);
                    
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 3000);
                }
            }
        }

        // Analytics & Backtesting Class
        class Analytics {
            constructor() {
                this.strategy = 'sma-cross';
                this.results = {};
                
                this.init();
            }

            init() {
                this.setupEventListeners();
            }

            setupEventListeners() {
                const runBtn = document.getElementById('runBacktest');
                const exportBtn = document.getElementById('exportResults');
                
                if (runBtn) runBtn.addEventListener('click', () => this.runBacktest());
                if (exportBtn) exportBtn.addEventListener('click', () => this.exportResults());
                
                document.querySelectorAll('[data-strategy]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-strategy]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.strategy = e.target.dataset.strategy;
                    });
                });
            }

            runBacktest() {
                const startDateElement = document.getElementById('backtest-start');
                const endDateElement = document.getElementById('backtest-end');
                const capitalElement = document.getElementById('backtest-capital');
                
                if (!startDateElement || !endDateElement || !capitalElement) {
                    console.error('Backtest form elements not found');
                    this.showMessage('Error: Formulario de backtest no encontrado', 'error');
                    return;
                }
                
                const startDate = startDateElement.value;
                const endDate = endDateElement.value;
                const capital = parseFloat(capitalElement.value);

                // Simulate backtest results
                const results = this.simulateBacktest(this.strategy, capital);
                
                document.getElementById('backtest-roi').textContent = `+${results.roi.toFixed(1)}%`;
                document.getElementById('backtest-sharpe').textContent = results.sharpe.toFixed(2);
                document.getElementById('backtest-drawdown').textContent = `${results.drawdown.toFixed(1)}%`;
                document.getElementById('backtest-winrate').textContent = `${results.winRate.toFixed(1)}%`;
                document.getElementById('backtest-trades').textContent = results.totalTrades;
                document.getElementById('backtest-duration').textContent = `${results.avgDuration} days`;
                document.getElementById('backtest-profit-factor').textContent = results.profitFactor.toFixed(2);

                this.showMessage('Backtest ejecutado correctamente', 'success');
            }

            simulateBacktest(strategy, capital) {
                // Simulated results for demo
                return {
                    roi: Math.random() * 50 + 10,
                    sharpe: Math.random() * 2 + 0.5,
                    drawdown: -(Math.random() * 15 + 5),
                    winRate: Math.random() * 30 + 50,
                    totalTrades: Math.floor(Math.random() * 100 + 50),
                    avgDuration: Math.floor(Math.random() * 10 + 3),
                    profitFactor: Math.random() * 2 + 1
                };
            }

            exportResults() {
                const data = {
                    strategy: this.strategy,
                    results: this.results,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `backtest-results-${this.strategy}-${new Date().getTime()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showMessage('Resultados exportados correctamente', 'success');
            }

            showMessage(message, type) {
                const messageArea = document.getElementById('messageArea-analytics');
                if (messageArea) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = type;
                    messageDiv.textContent = message;
                    
                    messageArea.innerHTML = '';
                    messageArea.appendChild(messageDiv);
                    
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 3000);
                }
            }
        }

        // Global helper functions
        function removeAlert(alertId) {
            if (window.alertsSystem) {
                window.alertsSystem.removeAlert(alertId);
            }
        }

        // Debug function for testing tab switching
        function testTabSwitch(tabId) {
            console.log('Testing tab switch to:', tabId);
            if (window.tabManager) {
                window.tabManager.switchTab(tabId);
            } else {
                console.error('TabManager not initialized');
            }
        }

        // Main Menu Navigation Functions for Telegram
        function showSection(sectionId) {
            console.log('Showing section:', sectionId);
            
            // Lista de secciones permitidas (solo los 4 botones principales)
            const allowedSections = ['spot-grid', 'futures-grid', 'manual-spot', 'manual-futures'];
            
            // Verificar si la secci√≥n est√° permitida
            if (!allowedSections.includes(sectionId)) {
                console.warn('Secci√≥n no permitida:', sectionId);
                return;
            }
            
            // Hide main menu
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu) {
                mainMenu.style.display = 'none';
            }
            
            // Hide all allowed sections only
            allowedSections.forEach(sectionName => {
                const section = document.getElementById(sectionName);
                if (section) {
                    section.style.display = 'none';
                }
            });
            
            // Show selected section
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                targetSection.style.display = 'block';
            }
            
            // Show tab navigation
            const tabNav = document.querySelector('.tab-navigation');
            if (tabNav) {
                tabNav.style.display = 'flex';
            }
            
            // Show back button
            const backBtn = document.querySelector('.back-to-overview');
            if (backBtn) {
                backBtn.style.display = 'inline-block';
            }
            
            // Activate corresponding tab if TabManager exists
            if (window.tabManager) {
                window.tabManager.switchTab(sectionId);
            }
            
            // Initialize specific section functionality
            initializeSectionData(sectionId);
            
            // Telegram WebApp optimization
            if (window.Telegram && window.Telegram.WebApp) {
                window.Telegram.WebApp.expand();
                window.Telegram.WebApp.sendData(JSON.stringify({
                    action: 'section_opened',
                    section: sectionId
                }));
            }
        }
        
        function showAllSections() {
            console.log('Showing all sections overview');
            
            // Lista de secciones permitidas (solo los 4 botones principales)
            const allowedSections = ['spot-grid', 'futures-grid', 'manual-spot', 'manual-futures'];
            
            // Show main menu
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu) {
                mainMenu.style.display = 'block';
            }
            
            // Hide only allowed sections
            allowedSections.forEach(sectionName => {
                const section = document.getElementById(sectionName);
                if (section) {
                    section.style.display = 'none';
                }
            });
            
            // Hide tab navigation
            const tabNav = document.querySelector('.tab-navigation');
            if (tabNav) {
                tabNav.style.display = 'none';
            }
            
            // Hide back button
            const backBtn = document.querySelector('.back-to-overview');
            if (backBtn) {
                backBtn.style.display = 'none';
            }
            
            // Telegram WebApp notification
            if (window.Telegram && window.Telegram.WebApp) {
                window.Telegram.WebApp.sendData(JSON.stringify({
                    action: 'main_menu_opened'
                }));
            }
        }
        
        function initializeSectionData(sectionId) {
            // Initialize data and UI for the specific section (solo secciones principales)
            switch(sectionId) {
                case 'spot-grid':
                    if (window.spotGridBot) {
                        window.spotGridBot.loadSavedData();
                        window.spotGridBot.updateDisplay();
                    }
                    break;
                case 'futures-grid':
                    if (window.futuresGridBot) {
                        window.futuresGridBot.loadSavedData();
                        window.futuresGridBot.updateDisplay();
                    }
                    break;
                case 'manual-spot':
                    if (window.manualSpotTrader) {
                        window.manualSpotTrader.loadSavedData();
                        window.manualSpotTrader.updateDisplay();
                    }
                    break;
                case 'manual-futures':
                    if (window.manualFuturesTrader) {
                        window.manualFuturesTrader.loadSavedData();
                        window.manualFuturesTrader.updateDisplay();
                    }
                    break;
                default:
                    console.warn('Secci√≥n no soportada para inicializaci√≥n:', sectionId);
                    break;
            }
        }
        
        // Initialize Telegram WebApp
        function initializeTelegramWebApp() {
            if (window.Telegram && window.Telegram.WebApp) {
                window.Telegram.WebApp.ready();
                window.Telegram.WebApp.expand();
                
                // Listen for back button
                window.Telegram.WebApp.onEvent('backButtonClicked', function() {
                    showAllSections();
                });
                
                console.log('Telegram WebApp initialized');
            }
        }
        
        // Initialize app on load
        window.addEventListener('DOMContentLoaded', function() {
            initializeTelegramWebApp();
            console.log('Telegram Trading App initialized');
        });

        // Make tabManager available globally for debugging
        window.tabManager = null;

        // Initialize the application
        let tabManager;
        window.addEventListener('load', () => {
            console.log('Initializing application...');
            
            try {
                // Setup data persistence first
                DataManager.setupResetButton();
                
                // Request notification permission
                if (Notification.permission === 'default') {
                    Notification.requestPermission();
                }
                
                // Initialize all systems
                console.log('Initializing trading systems...');
                window.dcaBot = new DCABot();
                window.portfolioManager = new PortfolioManager();
                window.analytics = new Analytics();
                window.alertsSystem = new AlertsSystem();
                
                // Initialize TabManager
                console.log('Initializing TabManager...');
                tabManager = new TabManager();
                window.tabManager = tabManager;
                
                // Initialize first tab (spot grid)
                console.log('Initializing SpotGridBot...');
                window.spotGridBot = new SpotGridTradingBot();
                
                console.log('Application initialization completed successfully');
            } catch (error) {
                console.error('Error during application initialization:', error);
            }
        });
    </script>
</body>
</html>
